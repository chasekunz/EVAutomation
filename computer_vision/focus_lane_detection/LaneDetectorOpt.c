/*
  File autogenerated by gengetopt version 2.22.6
  generated with the following command:
  gengetopt -i LaneDetectorOpt.ggo -F LaneDetectorOpt --func-name=LaneDetectorParser --arg-struct-name=LaneDetectorParserInfo --conf-parser 

  The developers of gengetopt consider the fixed text that goes in all
  gengetopt output files to be in the public domain:
  we make no copyright claims on it.
*/

/* If we use autoconf.  */
#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#ifndef FIX_UNUSED
#define FIX_UNUSED(X) (void) (X) /* avoid warnings for unused params */
#endif

#include <getopt.h>

#include "LaneDetectorOpt.h"

const char *LaneDetectorParserInfo_purpose = "";

const char *LaneDetectorParserInfo_usage = "Usage: LaneDetector [OPTIONS]...";

const char *LaneDetectorParserInfo_versiontext = "";

const char *LaneDetectorParserInfo_description = "";

const char *LaneDetectorParserInfo_help[] = {
  "  -h, --help                    Print help and exit",
  "  -V, --version                 Print version and exit",
  "      --ipmWidth=INT            width of IPM image to use",
  "      --ipmHeight=INT           height of IPM image to use",
  "      --ipmTop=INT              Top point in original image of region to make\n                                  IPM for",
  "      --ipmLeft=INT             Left point in original image of region to make\n                                  IPM for",
  "      --ipmRight=INT            Right point in original image region to make\n                                  IPM for",
  "      --ipmBottom=INT           Bottom point in original image region to make\n                                  IPM for",
  "      --ipmInterpolation=INT    The method to use for IPM interpolation",
  "      --lineWidth=DOUBLE        width of line to detect in mm (in the world)",
  "      --lineHeight=DOUBLE       height of line to detect in mm (in the world)",
  "      --kernelWidth=INT         widht of kernel to use for filtering",
  "      --kernelHeight=INT        Height of kernel to use for filtering",
  "      --lowerQuantile=DOUBLE    lower quantile to use for thresholding the\n                                  filtered image",
  "      --localMaxima=INT         whether to return local maxima or just the\n                                  maximum",
  "      --groupingType=INT        type of grouping to use (default 0: HV lines)",
  "      --binarize=DOUBLE         whether to binarize the thresholded image or\n                                  use the raw values",
  "      --detectionThreshold=DOUBLE\n                                threshold for line scores to declare as line",
  "      --smoothScores=INT        whether to smooth scores of lines detected or\n                                  not",
  "      --rMin=DOUBLE             rMin for Hough transform (in pixels)",
  "      --rMax=DOUBLE             rMax for Hough transform (in pixels)",
  "      --rStep=DOUBLE            rStep for Hough transform (in pixels)",
  "      --thetaMin=DOUBLE         thetaMin for Hough transform (in degrees)",
  "      --thetaMax=DOUBLE         thetaMax for Hough transform (in degrees)",
  "      --thetaStep=DOUBLE        thetaStep for Hough transform (in degrees)",
  "      --ipmVpPortion=DOUBLE     Portion of IPM image height to add to\n                                  y-coordinate of VP",
  "      --getEndPoints=INT        Get the endpoints of the line",
  "      --group=INT               group nearby lines or not (default 1: group)",
  "      --groupThreshold=DOUBLE   Threshold for grouping nearby lines (default\n                                  10)",
  "      --ransac=INT              use RANSAC (1) or not (0)",
  "      --ransacLineNumSamples=INT\n                                Number of samples to use for RANSAC",
  "      --ransacLineNumIterations=INT\n                                Number of iterations to use for RANSAC",
  "      --ransacLineNumGoodFit=INT\n                                Number of close points to consider a good line\n                                  fit",
  "      --ransacLineThreshold=DOUBLE\n                                Threshold to consider a point close",
  "      --ransacLineScoreThreshold=DOUBLE\n                                Threshold for detected line scores",
  "      --ransacLineBinarize=INT  Whether to binarize image for RANSAC or not",
  "      --ransacLineWindow=INT    Half width to use for ransac window",
  "      --ransacSplineNumSamples=INT\n                                Number of samples to use for RANSAC",
  "      --ransacSplineNumIterations=INT\n                                Number of iterations to use for RANSAC",
  "      --ransacSplineNumGoodFit=INT\n                                Number of close points to consider a good line\n                                  fit",
  "      --ransacSplineThreshold=DOUBLE\n                                Threshold to consider a point close",
  "      --ransacSplineScoreThreshold=DOUBLE\n                                Threshold for detected line scores",
  "      --ransacSplineBinarize=INT\n                                Whether to binarize image for RANSAC or not",
  "      --ransacSplineWindow=INT  Half width to use for ransac window",
  "      --ransacSplineDegree=INT  Degree of spline to use",
  "      --ransacSpline=INT        Whether to use splines",
  "      --ransacLine=INT          Whether to use lines",
  "      --ransacSplineStep=FLOAT  Step to use when pixelzing spline in ransac",
  "      --overlapThreshold=FLOAT  Overlap threshold to use for grouping of\n                                  bounding boxes",
  "      --localizeAngleThreshold=FLOAT\n                                Angle threshold used for localization (cosine,\n                                  1: most restrictive, 0: most liberal)",
  "      --localizeNumLinePixels=INT\n                                Number of pixels to go in normal direction for\n                                  localization",
  "      --extendAngleThreshold=FLOAT\n                                Angle threshold used for extending (cosine, 1:\n                                  most restrictive, 0: most liberal)",
  "      --extendMeanDirAngleThreshold=FLOAT\n                                Angle threshold from mean direction used for\n                                  extending (cosine, 1: most restrictive, 0:\n                                  most liberal)",
  "      --extendMeanDirAngleThresholdBack=FLOAT\n                                Angle threshold from mean direction used for\n                                  extending back (cosine, 1: most restrictive,\n                                  0: most liberal)",
  "      --extendMeanDirAngleThresholdForward=FLOAT\n                                Angle threshold from mean direction used for\n                                  extending forward (cosine, 1: most\n                                  restrictive, 0: most liberal)",
  "      --extendLinePixelsTangent=INT\n                                Number of pixels to go in tangent direction for\n                                  extending",
  "      --extendLinePixelsNormal=INT\n                                Number of pixels to go in tangent direction for\n                                  extending",
  "      --extendContThreshold=FLOAT\n                                Threhsold used for stopping the extending\n                                  process (higher -> less extending)",
  "      --extendDeviationThreshold=INT\n                                Stop extending when number of deviating points\n                                  exceeds this threshold",
  "      --extendRectTop=INT       Top point for extension bounding box",
  "      --extendRectBottom=INT    Bottom point for extension bounding box",
  "      --extendIPMAngleThreshold=FLOAT\n                                Angle threshold used for extending (cosine, 1:\n                                  most restrictive, 0: most liberal)",
  "      --extendIPMMeanDirAngleThreshold=FLOAT\n                                Angle threshold from mean direction used for\n                                  extending (cosine, 1: most restrictive, 0:\n                                  most liberal)",
  "      --extendIPMLinePixelsTangent=INT\n                                Number of pixels to go in tangent direction for\n                                  extending",
  "      --extendIPMLinePixelsNormal=INT\n                                Number of pixels to go in tangent direction for\n                                  extending",
  "      --extendIPMContThreshold=FLOAT\n                                Threhsold used for stopping the extending\n                                  process (higher -> less extending)",
  "      --extendIPMDeviationThreshold=INT\n                                Stop extending when number of deviating points\n                                  exceeds this threshold",
  "      --extendIPMRectTop=INT    Top point for extension bounding box",
  "      --extendIPMRectBottom=INT Bottom point for extension bounding box",
  "      --splineScoreJitter=INT   Number of pixels to go around the spline to\n                                  compute score",
  "      --splineScoreLengthRatio=FLOAT\n                                Ratio of spline length to use",
  "      --splineScoreAngleRatio=FLOAT\n                                Ratio of spline angle to use",
  "      --splineScoreStep=FLOAT   Step to use for spline score computation",
  "      --splineTrackingNumAbsentFrames=INT\n                                number of frames the track is allowed to be\n                                  absent before deleting it",
  "      --splineTrackingNumSeenFrames=INT\n                                number of frames before considering the track\n                                  good",
  "      --mergeSplineThetaThreshold=FLOAT\n                                Angle threshold for merging splines (radians)",
  "      --mergeSplineRThreshold=FLOAT\n                                R threshold (distance from origin) for merginn\n                                  splines",
  "      --mergeSplineMeanThetaThreshold=FLOAT\n                                Mean Angle threshold for merging splines\n                                  (radians)",
  "      --mergeSplineMeanRThreshold=FLOAT\n                                Mean R threshold (distance from origin) for\n                                  merginn splines",
  "      --mergeSplineCentroidThreshold=FLOAT\n                                Distance threshold between spline cetroids for\n                                  merging",
  "      --lineTrackingNumAbsentFrames=INT\n                                number of frames the track is allowed to be\n                                  absent before deleting it",
  "      --lineTrackingNumSeenFrames=INT\n                                number of frames before considering the track\n                                  good",
  "      --mergeLineThetaThreshold=FLOAT\n                                Angle threshold for merging lines (radians)",
  "      --mergeLineRThreshold=FLOAT\n                                R threshold (distance from origin) for merging\n                                  lines",
  "      --numStrips=INT           Number of horizontal strips to divide the image\n                                  to",
  "      --checkSplines=INT        Whtethet to check splines or not",
  "      --checkSplinesCurvenessThreshold=FLOAT\n                                Curveness Threshold for checking splines",
  "      --checkSplinesLengthThreshold=FLOAT\n                                Length Threshold for checking splines",
  "      --checkSplinesThetaDiffThreshold=FLOAT\n                                ThetaDiff Threshold for checking splines",
  "      --checkSplinesThetaThreshold=FLOAT\n                                ThetaThreshold Threshold for checking splines",
  "      --checkIPMSplines=INT     Whtethet to check IPM splines or not",
  "      --checkIPMSplinesCurvenessThreshold=FLOAT\n                                Curveness Threshold for checking splines",
  "      --checkIPMSplinesLengthThreshold=FLOAT\n                                Length Threshold for checking splines",
  "      --checkIPMSplinesThetaDiffThreshold=FLOAT\n                                ThetaDiff Threshold for checking splines",
  "      --checkIPMSplinesThetaThreshold=FLOAT\n                                ThetaThreshold Threshold for checking splines",
  "      --finalSplineScoreThreshold=FLOAT\n                                Final Threshold for declaring a valid spline",
  "      --useGroundPlane=INT      Use groudn plane or not when sending to map",
  "      --checkColor=INT          Whether to check colors or not",
  "      --checkColorWindow=INT    Size of window to use",
  "      --checkColorNumBins=INT   Number of bins to use",
  "      --checkColorNumYellowMin=FLOAT\n                                Min ratio of yellow points",
  "      --checkColorRGMin=FLOAT   Min RG diff",
  "      --checkColorRGMax=FLOAT   Max RG diff",
  "      --checkColorGBMin=FLOAT   Min GB diff",
  "      --checkColorRBMin=FLOAT   Min RB diff",
  "      --checkColorRBFThreshold=FLOAT\n                                RBF Threshold",
  "      --checkColorRBF=INT       Whether to use RBF or not",
  "      --ipmWindowClear=INT      Whether to clear part of the IPM image",
  "      --ipmWindowLeft=INT       Left corrdinate of window to keep in IPM",
  "      --ipmWindowRight=INT      Left corrdinate of window to keep in IPM",
  "      --checkLaneWidth=INT      Whether to check lane width or not",
  "      --checkLaneWidthMean=FLOAT\n                                Mean of lane width to look for",
  "      --checkLaneWidthStd=FLOAT Std deviation of lane width to look for",
    0
};

typedef enum {ARG_NO
  , ARG_INT
  , ARG_FLOAT
  , ARG_DOUBLE
} LaneDetectorParser_arg_type;

static
void clear_given (struct LaneDetectorParserInfo *args_info);
static
void clear_args (struct LaneDetectorParserInfo *args_info);

static int
LaneDetectorParser_internal (int argc, char **argv, struct LaneDetectorParserInfo *args_info,
                        struct LaneDetectorParser_params *params, const char *additional_error);

static int
LaneDetectorParser_required2 (struct LaneDetectorParserInfo *args_info, const char *prog_name, const char *additional_error);
struct line_list
{
  char * string_arg;
  struct line_list * next;
};

static struct line_list *cmd_line_list = 0;
static struct line_list *cmd_line_list_tmp = 0;

static void
free_cmd_list(void)
{
  /* free the list of a previous call */
  if (cmd_line_list)
    {
      while (cmd_line_list) {
        cmd_line_list_tmp = cmd_line_list;
        cmd_line_list = cmd_line_list->next;
        free (cmd_line_list_tmp->string_arg);
        free (cmd_line_list_tmp);
      }
    }
}


static char *
gengetopt_strdup (const char *s);

static
void clear_given (struct LaneDetectorParserInfo *args_info)
{
  args_info->help_given = 0 ;
  args_info->version_given = 0 ;
  args_info->ipmWidth_given = 0 ;
  args_info->ipmHeight_given = 0 ;
  args_info->ipmTop_given = 0 ;
  args_info->ipmLeft_given = 0 ;
  args_info->ipmRight_given = 0 ;
  args_info->ipmBottom_given = 0 ;
  args_info->ipmInterpolation_given = 0 ;
  args_info->lineWidth_given = 0 ;
  args_info->lineHeight_given = 0 ;
  args_info->kernelWidth_given = 0 ;
  args_info->kernelHeight_given = 0 ;
  args_info->lowerQuantile_given = 0 ;
  args_info->localMaxima_given = 0 ;
  args_info->groupingType_given = 0 ;
  args_info->binarize_given = 0 ;
  args_info->detectionThreshold_given = 0 ;
  args_info->smoothScores_given = 0 ;
  args_info->rMin_given = 0 ;
  args_info->rMax_given = 0 ;
  args_info->rStep_given = 0 ;
  args_info->thetaMin_given = 0 ;
  args_info->thetaMax_given = 0 ;
  args_info->thetaStep_given = 0 ;
  args_info->ipmVpPortion_given = 0 ;
  args_info->getEndPoints_given = 0 ;
  args_info->group_given = 0 ;
  args_info->groupThreshold_given = 0 ;
  args_info->ransac_given = 0 ;
  args_info->ransacLineNumSamples_given = 0 ;
  args_info->ransacLineNumIterations_given = 0 ;
  args_info->ransacLineNumGoodFit_given = 0 ;
  args_info->ransacLineThreshold_given = 0 ;
  args_info->ransacLineScoreThreshold_given = 0 ;
  args_info->ransacLineBinarize_given = 0 ;
  args_info->ransacLineWindow_given = 0 ;
  args_info->ransacSplineNumSamples_given = 0 ;
  args_info->ransacSplineNumIterations_given = 0 ;
  args_info->ransacSplineNumGoodFit_given = 0 ;
  args_info->ransacSplineThreshold_given = 0 ;
  args_info->ransacSplineScoreThreshold_given = 0 ;
  args_info->ransacSplineBinarize_given = 0 ;
  args_info->ransacSplineWindow_given = 0 ;
  args_info->ransacSplineDegree_given = 0 ;
  args_info->ransacSpline_given = 0 ;
  args_info->ransacLine_given = 0 ;
  args_info->ransacSplineStep_given = 0 ;
  args_info->overlapThreshold_given = 0 ;
  args_info->localizeAngleThreshold_given = 0 ;
  args_info->localizeNumLinePixels_given = 0 ;
  args_info->extendAngleThreshold_given = 0 ;
  args_info->extendMeanDirAngleThreshold_given = 0 ;
  args_info->extendMeanDirAngleThresholdBack_given = 0 ;
  args_info->extendMeanDirAngleThresholdForward_given = 0 ;
  args_info->extendLinePixelsTangent_given = 0 ;
  args_info->extendLinePixelsNormal_given = 0 ;
  args_info->extendContThreshold_given = 0 ;
  args_info->extendDeviationThreshold_given = 0 ;
  args_info->extendRectTop_given = 0 ;
  args_info->extendRectBottom_given = 0 ;
  args_info->extendIPMAngleThreshold_given = 0 ;
  args_info->extendIPMMeanDirAngleThreshold_given = 0 ;
  args_info->extendIPMLinePixelsTangent_given = 0 ;
  args_info->extendIPMLinePixelsNormal_given = 0 ;
  args_info->extendIPMContThreshold_given = 0 ;
  args_info->extendIPMDeviationThreshold_given = 0 ;
  args_info->extendIPMRectTop_given = 0 ;
  args_info->extendIPMRectBottom_given = 0 ;
  args_info->splineScoreJitter_given = 0 ;
  args_info->splineScoreLengthRatio_given = 0 ;
  args_info->splineScoreAngleRatio_given = 0 ;
  args_info->splineScoreStep_given = 0 ;
  args_info->splineTrackingNumAbsentFrames_given = 0 ;
  args_info->splineTrackingNumSeenFrames_given = 0 ;
  args_info->mergeSplineThetaThreshold_given = 0 ;
  args_info->mergeSplineRThreshold_given = 0 ;
  args_info->mergeSplineMeanThetaThreshold_given = 0 ;
  args_info->mergeSplineMeanRThreshold_given = 0 ;
  args_info->mergeSplineCentroidThreshold_given = 0 ;
  args_info->lineTrackingNumAbsentFrames_given = 0 ;
  args_info->lineTrackingNumSeenFrames_given = 0 ;
  args_info->mergeLineThetaThreshold_given = 0 ;
  args_info->mergeLineRThreshold_given = 0 ;
  args_info->numStrips_given = 0 ;
  args_info->checkSplines_given = 0 ;
  args_info->checkSplinesCurvenessThreshold_given = 0 ;
  args_info->checkSplinesLengthThreshold_given = 0 ;
  args_info->checkSplinesThetaDiffThreshold_given = 0 ;
  args_info->checkSplinesThetaThreshold_given = 0 ;
  args_info->checkIPMSplines_given = 0 ;
  args_info->checkIPMSplinesCurvenessThreshold_given = 0 ;
  args_info->checkIPMSplinesLengthThreshold_given = 0 ;
  args_info->checkIPMSplinesThetaDiffThreshold_given = 0 ;
  args_info->checkIPMSplinesThetaThreshold_given = 0 ;
  args_info->finalSplineScoreThreshold_given = 0 ;
  args_info->useGroundPlane_given = 0 ;
  args_info->checkColor_given = 0 ;
  args_info->checkColorWindow_given = 0 ;
  args_info->checkColorNumBins_given = 0 ;
  args_info->checkColorNumYellowMin_given = 0 ;
  args_info->checkColorRGMin_given = 0 ;
  args_info->checkColorRGMax_given = 0 ;
  args_info->checkColorGBMin_given = 0 ;
  args_info->checkColorRBMin_given = 0 ;
  args_info->checkColorRBFThreshold_given = 0 ;
  args_info->checkColorRBF_given = 0 ;
  args_info->ipmWindowClear_given = 0 ;
  args_info->ipmWindowLeft_given = 0 ;
  args_info->ipmWindowRight_given = 0 ;
  args_info->checkLaneWidth_given = 0 ;
  args_info->checkLaneWidthMean_given = 0 ;
  args_info->checkLaneWidthStd_given = 0 ;
}

static
void clear_args (struct LaneDetectorParserInfo *args_info)
{
  FIX_UNUSED (args_info);
  args_info->ipmWidth_orig = NULL;
  args_info->ipmHeight_orig = NULL;
  args_info->ipmTop_orig = NULL;
  args_info->ipmLeft_orig = NULL;
  args_info->ipmRight_orig = NULL;
  args_info->ipmBottom_orig = NULL;
  args_info->ipmInterpolation_orig = NULL;
  args_info->lineWidth_orig = NULL;
  args_info->lineHeight_orig = NULL;
  args_info->kernelWidth_orig = NULL;
  args_info->kernelHeight_orig = NULL;
  args_info->lowerQuantile_orig = NULL;
  args_info->localMaxima_orig = NULL;
  args_info->groupingType_orig = NULL;
  args_info->binarize_orig = NULL;
  args_info->detectionThreshold_orig = NULL;
  args_info->smoothScores_orig = NULL;
  args_info->rMin_orig = NULL;
  args_info->rMax_orig = NULL;
  args_info->rStep_orig = NULL;
  args_info->thetaMin_orig = NULL;
  args_info->thetaMax_orig = NULL;
  args_info->thetaStep_orig = NULL;
  args_info->ipmVpPortion_orig = NULL;
  args_info->getEndPoints_orig = NULL;
  args_info->group_orig = NULL;
  args_info->groupThreshold_orig = NULL;
  args_info->ransac_orig = NULL;
  args_info->ransacLineNumSamples_orig = NULL;
  args_info->ransacLineNumIterations_orig = NULL;
  args_info->ransacLineNumGoodFit_orig = NULL;
  args_info->ransacLineThreshold_orig = NULL;
  args_info->ransacLineScoreThreshold_orig = NULL;
  args_info->ransacLineBinarize_orig = NULL;
  args_info->ransacLineWindow_orig = NULL;
  args_info->ransacSplineNumSamples_orig = NULL;
  args_info->ransacSplineNumIterations_orig = NULL;
  args_info->ransacSplineNumGoodFit_orig = NULL;
  args_info->ransacSplineThreshold_orig = NULL;
  args_info->ransacSplineScoreThreshold_orig = NULL;
  args_info->ransacSplineBinarize_orig = NULL;
  args_info->ransacSplineWindow_orig = NULL;
  args_info->ransacSplineDegree_orig = NULL;
  args_info->ransacSpline_orig = NULL;
  args_info->ransacLine_orig = NULL;
  args_info->ransacSplineStep_orig = NULL;
  args_info->overlapThreshold_orig = NULL;
  args_info->localizeAngleThreshold_orig = NULL;
  args_info->localizeNumLinePixels_orig = NULL;
  args_info->extendAngleThreshold_orig = NULL;
  args_info->extendMeanDirAngleThreshold_orig = NULL;
  args_info->extendMeanDirAngleThresholdBack_orig = NULL;
  args_info->extendMeanDirAngleThresholdForward_orig = NULL;
  args_info->extendLinePixelsTangent_orig = NULL;
  args_info->extendLinePixelsNormal_orig = NULL;
  args_info->extendContThreshold_orig = NULL;
  args_info->extendDeviationThreshold_orig = NULL;
  args_info->extendRectTop_orig = NULL;
  args_info->extendRectBottom_orig = NULL;
  args_info->extendIPMAngleThreshold_orig = NULL;
  args_info->extendIPMMeanDirAngleThreshold_orig = NULL;
  args_info->extendIPMLinePixelsTangent_orig = NULL;
  args_info->extendIPMLinePixelsNormal_orig = NULL;
  args_info->extendIPMContThreshold_orig = NULL;
  args_info->extendIPMDeviationThreshold_orig = NULL;
  args_info->extendIPMRectTop_orig = NULL;
  args_info->extendIPMRectBottom_orig = NULL;
  args_info->splineScoreJitter_orig = NULL;
  args_info->splineScoreLengthRatio_orig = NULL;
  args_info->splineScoreAngleRatio_orig = NULL;
  args_info->splineScoreStep_orig = NULL;
  args_info->splineTrackingNumAbsentFrames_orig = NULL;
  args_info->splineTrackingNumSeenFrames_orig = NULL;
  args_info->mergeSplineThetaThreshold_orig = NULL;
  args_info->mergeSplineRThreshold_orig = NULL;
  args_info->mergeSplineMeanThetaThreshold_orig = NULL;
  args_info->mergeSplineMeanRThreshold_orig = NULL;
  args_info->mergeSplineCentroidThreshold_orig = NULL;
  args_info->lineTrackingNumAbsentFrames_orig = NULL;
  args_info->lineTrackingNumSeenFrames_orig = NULL;
  args_info->mergeLineThetaThreshold_orig = NULL;
  args_info->mergeLineRThreshold_orig = NULL;
  args_info->numStrips_orig = NULL;
  args_info->checkSplines_orig = NULL;
  args_info->checkSplinesCurvenessThreshold_orig = NULL;
  args_info->checkSplinesLengthThreshold_orig = NULL;
  args_info->checkSplinesThetaDiffThreshold_orig = NULL;
  args_info->checkSplinesThetaThreshold_orig = NULL;
  args_info->checkIPMSplines_orig = NULL;
  args_info->checkIPMSplinesCurvenessThreshold_orig = NULL;
  args_info->checkIPMSplinesLengthThreshold_orig = NULL;
  args_info->checkIPMSplinesThetaDiffThreshold_orig = NULL;
  args_info->checkIPMSplinesThetaThreshold_orig = NULL;
  args_info->finalSplineScoreThreshold_orig = NULL;
  args_info->useGroundPlane_orig = NULL;
  args_info->checkColor_orig = NULL;
  args_info->checkColorWindow_orig = NULL;
  args_info->checkColorNumBins_orig = NULL;
  args_info->checkColorNumYellowMin_orig = NULL;
  args_info->checkColorRGMin_orig = NULL;
  args_info->checkColorRGMax_orig = NULL;
  args_info->checkColorGBMin_orig = NULL;
  args_info->checkColorRBMin_orig = NULL;
  args_info->checkColorRBFThreshold_orig = NULL;
  args_info->checkColorRBF_orig = NULL;
  args_info->ipmWindowClear_orig = NULL;
  args_info->ipmWindowLeft_orig = NULL;
  args_info->ipmWindowRight_orig = NULL;
  args_info->checkLaneWidth_orig = NULL;
  args_info->checkLaneWidthMean_orig = NULL;
  args_info->checkLaneWidthStd_orig = NULL;
  
}

static
void init_args_info(struct LaneDetectorParserInfo *args_info)
{


  args_info->help_help = LaneDetectorParserInfo_help[0] ;
  args_info->version_help = LaneDetectorParserInfo_help[1] ;
  args_info->ipmWidth_help = LaneDetectorParserInfo_help[2] ;
  args_info->ipmHeight_help = LaneDetectorParserInfo_help[3] ;
  args_info->ipmTop_help = LaneDetectorParserInfo_help[4] ;
  args_info->ipmLeft_help = LaneDetectorParserInfo_help[5] ;
  args_info->ipmRight_help = LaneDetectorParserInfo_help[6] ;
  args_info->ipmBottom_help = LaneDetectorParserInfo_help[7] ;
  args_info->ipmInterpolation_help = LaneDetectorParserInfo_help[8] ;
  args_info->lineWidth_help = LaneDetectorParserInfo_help[9] ;
  args_info->lineHeight_help = LaneDetectorParserInfo_help[10] ;
  args_info->kernelWidth_help = LaneDetectorParserInfo_help[11] ;
  args_info->kernelHeight_help = LaneDetectorParserInfo_help[12] ;
  args_info->lowerQuantile_help = LaneDetectorParserInfo_help[13] ;
  args_info->localMaxima_help = LaneDetectorParserInfo_help[14] ;
  args_info->groupingType_help = LaneDetectorParserInfo_help[15] ;
  args_info->binarize_help = LaneDetectorParserInfo_help[16] ;
  args_info->detectionThreshold_help = LaneDetectorParserInfo_help[17] ;
  args_info->smoothScores_help = LaneDetectorParserInfo_help[18] ;
  args_info->rMin_help = LaneDetectorParserInfo_help[19] ;
  args_info->rMax_help = LaneDetectorParserInfo_help[20] ;
  args_info->rStep_help = LaneDetectorParserInfo_help[21] ;
  args_info->thetaMin_help = LaneDetectorParserInfo_help[22] ;
  args_info->thetaMax_help = LaneDetectorParserInfo_help[23] ;
  args_info->thetaStep_help = LaneDetectorParserInfo_help[24] ;
  args_info->ipmVpPortion_help = LaneDetectorParserInfo_help[25] ;
  args_info->getEndPoints_help = LaneDetectorParserInfo_help[26] ;
  args_info->group_help = LaneDetectorParserInfo_help[27] ;
  args_info->groupThreshold_help = LaneDetectorParserInfo_help[28] ;
  args_info->ransac_help = LaneDetectorParserInfo_help[29] ;
  args_info->ransacLineNumSamples_help = LaneDetectorParserInfo_help[30] ;
  args_info->ransacLineNumIterations_help = LaneDetectorParserInfo_help[31] ;
  args_info->ransacLineNumGoodFit_help = LaneDetectorParserInfo_help[32] ;
  args_info->ransacLineThreshold_help = LaneDetectorParserInfo_help[33] ;
  args_info->ransacLineScoreThreshold_help = LaneDetectorParserInfo_help[34] ;
  args_info->ransacLineBinarize_help = LaneDetectorParserInfo_help[35] ;
  args_info->ransacLineWindow_help = LaneDetectorParserInfo_help[36] ;
  args_info->ransacSplineNumSamples_help = LaneDetectorParserInfo_help[37] ;
  args_info->ransacSplineNumIterations_help = LaneDetectorParserInfo_help[38] ;
  args_info->ransacSplineNumGoodFit_help = LaneDetectorParserInfo_help[39] ;
  args_info->ransacSplineThreshold_help = LaneDetectorParserInfo_help[40] ;
  args_info->ransacSplineScoreThreshold_help = LaneDetectorParserInfo_help[41] ;
  args_info->ransacSplineBinarize_help = LaneDetectorParserInfo_help[42] ;
  args_info->ransacSplineWindow_help = LaneDetectorParserInfo_help[43] ;
  args_info->ransacSplineDegree_help = LaneDetectorParserInfo_help[44] ;
  args_info->ransacSpline_help = LaneDetectorParserInfo_help[45] ;
  args_info->ransacLine_help = LaneDetectorParserInfo_help[46] ;
  args_info->ransacSplineStep_help = LaneDetectorParserInfo_help[47] ;
  args_info->overlapThreshold_help = LaneDetectorParserInfo_help[48] ;
  args_info->localizeAngleThreshold_help = LaneDetectorParserInfo_help[49] ;
  args_info->localizeNumLinePixels_help = LaneDetectorParserInfo_help[50] ;
  args_info->extendAngleThreshold_help = LaneDetectorParserInfo_help[51] ;
  args_info->extendMeanDirAngleThreshold_help = LaneDetectorParserInfo_help[52] ;
  args_info->extendMeanDirAngleThresholdBack_help = LaneDetectorParserInfo_help[53] ;
  args_info->extendMeanDirAngleThresholdForward_help = LaneDetectorParserInfo_help[54] ;
  args_info->extendLinePixelsTangent_help = LaneDetectorParserInfo_help[55] ;
  args_info->extendLinePixelsNormal_help = LaneDetectorParserInfo_help[56] ;
  args_info->extendContThreshold_help = LaneDetectorParserInfo_help[57] ;
  args_info->extendDeviationThreshold_help = LaneDetectorParserInfo_help[58] ;
  args_info->extendRectTop_help = LaneDetectorParserInfo_help[59] ;
  args_info->extendRectBottom_help = LaneDetectorParserInfo_help[60] ;
  args_info->extendIPMAngleThreshold_help = LaneDetectorParserInfo_help[61] ;
  args_info->extendIPMMeanDirAngleThreshold_help = LaneDetectorParserInfo_help[62] ;
  args_info->extendIPMLinePixelsTangent_help = LaneDetectorParserInfo_help[63] ;
  args_info->extendIPMLinePixelsNormal_help = LaneDetectorParserInfo_help[64] ;
  args_info->extendIPMContThreshold_help = LaneDetectorParserInfo_help[65] ;
  args_info->extendIPMDeviationThreshold_help = LaneDetectorParserInfo_help[66] ;
  args_info->extendIPMRectTop_help = LaneDetectorParserInfo_help[67] ;
  args_info->extendIPMRectBottom_help = LaneDetectorParserInfo_help[68] ;
  args_info->splineScoreJitter_help = LaneDetectorParserInfo_help[69] ;
  args_info->splineScoreLengthRatio_help = LaneDetectorParserInfo_help[70] ;
  args_info->splineScoreAngleRatio_help = LaneDetectorParserInfo_help[71] ;
  args_info->splineScoreStep_help = LaneDetectorParserInfo_help[72] ;
  args_info->splineTrackingNumAbsentFrames_help = LaneDetectorParserInfo_help[73] ;
  args_info->splineTrackingNumSeenFrames_help = LaneDetectorParserInfo_help[74] ;
  args_info->mergeSplineThetaThreshold_help = LaneDetectorParserInfo_help[75] ;
  args_info->mergeSplineRThreshold_help = LaneDetectorParserInfo_help[76] ;
  args_info->mergeSplineMeanThetaThreshold_help = LaneDetectorParserInfo_help[77] ;
  args_info->mergeSplineMeanRThreshold_help = LaneDetectorParserInfo_help[78] ;
  args_info->mergeSplineCentroidThreshold_help = LaneDetectorParserInfo_help[79] ;
  args_info->lineTrackingNumAbsentFrames_help = LaneDetectorParserInfo_help[80] ;
  args_info->lineTrackingNumSeenFrames_help = LaneDetectorParserInfo_help[81] ;
  args_info->mergeLineThetaThreshold_help = LaneDetectorParserInfo_help[82] ;
  args_info->mergeLineRThreshold_help = LaneDetectorParserInfo_help[83] ;
  args_info->numStrips_help = LaneDetectorParserInfo_help[84] ;
  args_info->checkSplines_help = LaneDetectorParserInfo_help[85] ;
  args_info->checkSplinesCurvenessThreshold_help = LaneDetectorParserInfo_help[86] ;
  args_info->checkSplinesLengthThreshold_help = LaneDetectorParserInfo_help[87] ;
  args_info->checkSplinesThetaDiffThreshold_help = LaneDetectorParserInfo_help[88] ;
  args_info->checkSplinesThetaThreshold_help = LaneDetectorParserInfo_help[89] ;
  args_info->checkIPMSplines_help = LaneDetectorParserInfo_help[90] ;
  args_info->checkIPMSplinesCurvenessThreshold_help = LaneDetectorParserInfo_help[91] ;
  args_info->checkIPMSplinesLengthThreshold_help = LaneDetectorParserInfo_help[92] ;
  args_info->checkIPMSplinesThetaDiffThreshold_help = LaneDetectorParserInfo_help[93] ;
  args_info->checkIPMSplinesThetaThreshold_help = LaneDetectorParserInfo_help[94] ;
  args_info->finalSplineScoreThreshold_help = LaneDetectorParserInfo_help[95] ;
  args_info->useGroundPlane_help = LaneDetectorParserInfo_help[96] ;
  args_info->checkColor_help = LaneDetectorParserInfo_help[97] ;
  args_info->checkColorWindow_help = LaneDetectorParserInfo_help[98] ;
  args_info->checkColorNumBins_help = LaneDetectorParserInfo_help[99] ;
  args_info->checkColorNumYellowMin_help = LaneDetectorParserInfo_help[100] ;
  args_info->checkColorRGMin_help = LaneDetectorParserInfo_help[101] ;
  args_info->checkColorRGMax_help = LaneDetectorParserInfo_help[102] ;
  args_info->checkColorGBMin_help = LaneDetectorParserInfo_help[103] ;
  args_info->checkColorRBMin_help = LaneDetectorParserInfo_help[104] ;
  args_info->checkColorRBFThreshold_help = LaneDetectorParserInfo_help[105] ;
  args_info->checkColorRBF_help = LaneDetectorParserInfo_help[106] ;
  args_info->ipmWindowClear_help = LaneDetectorParserInfo_help[107] ;
  args_info->ipmWindowLeft_help = LaneDetectorParserInfo_help[108] ;
  args_info->ipmWindowRight_help = LaneDetectorParserInfo_help[109] ;
  args_info->checkLaneWidth_help = LaneDetectorParserInfo_help[110] ;
  args_info->checkLaneWidthMean_help = LaneDetectorParserInfo_help[111] ;
  args_info->checkLaneWidthStd_help = LaneDetectorParserInfo_help[112] ;
  
}

void
LaneDetectorParser_print_version (void)
{
  printf ("%s %s\n",
     (strlen(LANEDETECTORPARSER_PACKAGE_NAME) ? LANEDETECTORPARSER_PACKAGE_NAME : LANEDETECTORPARSER_PACKAGE),
     LANEDETECTORPARSER_VERSION);

  if (strlen(LaneDetectorParserInfo_versiontext) > 0)
    printf("\n%s\n", LaneDetectorParserInfo_versiontext);
}

static void print_help_common(void) {
  LaneDetectorParser_print_version ();

  if (strlen(LaneDetectorParserInfo_purpose) > 0)
    printf("\n%s\n", LaneDetectorParserInfo_purpose);

  if (strlen(LaneDetectorParserInfo_usage) > 0)
    printf("\n%s\n", LaneDetectorParserInfo_usage);

  printf("\n");

  if (strlen(LaneDetectorParserInfo_description) > 0)
    printf("%s\n\n", LaneDetectorParserInfo_description);
}

void
LaneDetectorParser_print_help (void)
{
  int i = 0;
  print_help_common();
  while (LaneDetectorParserInfo_help[i])
    printf("%s\n", LaneDetectorParserInfo_help[i++]);
}

void
LaneDetectorParser_init (struct LaneDetectorParserInfo *args_info)
{
  clear_given (args_info);
  clear_args (args_info);
  init_args_info (args_info);
}

void
LaneDetectorParser_params_init(struct LaneDetectorParser_params *params)
{
  if (params)
    { 
      params->override = 0;
      params->initialize = 1;
      params->check_required = 1;
      params->check_ambiguity = 0;
      params->print_errors = 1;
    }
}

struct LaneDetectorParser_params *
LaneDetectorParser_params_create(void)
{
  struct LaneDetectorParser_params *params = 
    (struct LaneDetectorParser_params *)malloc(sizeof(struct LaneDetectorParser_params));
  LaneDetectorParser_params_init(params);  
  return params;
}

static void
free_string_field (char **s)
{
  if (*s)
    {
      free (*s);
      *s = 0;
    }
}


static void
LaneDetectorParser_release (struct LaneDetectorParserInfo *args_info)
{

  free_string_field (&(args_info->ipmWidth_orig));
  free_string_field (&(args_info->ipmHeight_orig));
  free_string_field (&(args_info->ipmTop_orig));
  free_string_field (&(args_info->ipmLeft_orig));
  free_string_field (&(args_info->ipmRight_orig));
  free_string_field (&(args_info->ipmBottom_orig));
  free_string_field (&(args_info->ipmInterpolation_orig));
  free_string_field (&(args_info->lineWidth_orig));
  free_string_field (&(args_info->lineHeight_orig));
  free_string_field (&(args_info->kernelWidth_orig));
  free_string_field (&(args_info->kernelHeight_orig));
  free_string_field (&(args_info->lowerQuantile_orig));
  free_string_field (&(args_info->localMaxima_orig));
  free_string_field (&(args_info->groupingType_orig));
  free_string_field (&(args_info->binarize_orig));
  free_string_field (&(args_info->detectionThreshold_orig));
  free_string_field (&(args_info->smoothScores_orig));
  free_string_field (&(args_info->rMin_orig));
  free_string_field (&(args_info->rMax_orig));
  free_string_field (&(args_info->rStep_orig));
  free_string_field (&(args_info->thetaMin_orig));
  free_string_field (&(args_info->thetaMax_orig));
  free_string_field (&(args_info->thetaStep_orig));
  free_string_field (&(args_info->ipmVpPortion_orig));
  free_string_field (&(args_info->getEndPoints_orig));
  free_string_field (&(args_info->group_orig));
  free_string_field (&(args_info->groupThreshold_orig));
  free_string_field (&(args_info->ransac_orig));
  free_string_field (&(args_info->ransacLineNumSamples_orig));
  free_string_field (&(args_info->ransacLineNumIterations_orig));
  free_string_field (&(args_info->ransacLineNumGoodFit_orig));
  free_string_field (&(args_info->ransacLineThreshold_orig));
  free_string_field (&(args_info->ransacLineScoreThreshold_orig));
  free_string_field (&(args_info->ransacLineBinarize_orig));
  free_string_field (&(args_info->ransacLineWindow_orig));
  free_string_field (&(args_info->ransacSplineNumSamples_orig));
  free_string_field (&(args_info->ransacSplineNumIterations_orig));
  free_string_field (&(args_info->ransacSplineNumGoodFit_orig));
  free_string_field (&(args_info->ransacSplineThreshold_orig));
  free_string_field (&(args_info->ransacSplineScoreThreshold_orig));
  free_string_field (&(args_info->ransacSplineBinarize_orig));
  free_string_field (&(args_info->ransacSplineWindow_orig));
  free_string_field (&(args_info->ransacSplineDegree_orig));
  free_string_field (&(args_info->ransacSpline_orig));
  free_string_field (&(args_info->ransacLine_orig));
  free_string_field (&(args_info->ransacSplineStep_orig));
  free_string_field (&(args_info->overlapThreshold_orig));
  free_string_field (&(args_info->localizeAngleThreshold_orig));
  free_string_field (&(args_info->localizeNumLinePixels_orig));
  free_string_field (&(args_info->extendAngleThreshold_orig));
  free_string_field (&(args_info->extendMeanDirAngleThreshold_orig));
  free_string_field (&(args_info->extendMeanDirAngleThresholdBack_orig));
  free_string_field (&(args_info->extendMeanDirAngleThresholdForward_orig));
  free_string_field (&(args_info->extendLinePixelsTangent_orig));
  free_string_field (&(args_info->extendLinePixelsNormal_orig));
  free_string_field (&(args_info->extendContThreshold_orig));
  free_string_field (&(args_info->extendDeviationThreshold_orig));
  free_string_field (&(args_info->extendRectTop_orig));
  free_string_field (&(args_info->extendRectBottom_orig));
  free_string_field (&(args_info->extendIPMAngleThreshold_orig));
  free_string_field (&(args_info->extendIPMMeanDirAngleThreshold_orig));
  free_string_field (&(args_info->extendIPMLinePixelsTangent_orig));
  free_string_field (&(args_info->extendIPMLinePixelsNormal_orig));
  free_string_field (&(args_info->extendIPMContThreshold_orig));
  free_string_field (&(args_info->extendIPMDeviationThreshold_orig));
  free_string_field (&(args_info->extendIPMRectTop_orig));
  free_string_field (&(args_info->extendIPMRectBottom_orig));
  free_string_field (&(args_info->splineScoreJitter_orig));
  free_string_field (&(args_info->splineScoreLengthRatio_orig));
  free_string_field (&(args_info->splineScoreAngleRatio_orig));
  free_string_field (&(args_info->splineScoreStep_orig));
  free_string_field (&(args_info->splineTrackingNumAbsentFrames_orig));
  free_string_field (&(args_info->splineTrackingNumSeenFrames_orig));
  free_string_field (&(args_info->mergeSplineThetaThreshold_orig));
  free_string_field (&(args_info->mergeSplineRThreshold_orig));
  free_string_field (&(args_info->mergeSplineMeanThetaThreshold_orig));
  free_string_field (&(args_info->mergeSplineMeanRThreshold_orig));
  free_string_field (&(args_info->mergeSplineCentroidThreshold_orig));
  free_string_field (&(args_info->lineTrackingNumAbsentFrames_orig));
  free_string_field (&(args_info->lineTrackingNumSeenFrames_orig));
  free_string_field (&(args_info->mergeLineThetaThreshold_orig));
  free_string_field (&(args_info->mergeLineRThreshold_orig));
  free_string_field (&(args_info->numStrips_orig));
  free_string_field (&(args_info->checkSplines_orig));
  free_string_field (&(args_info->checkSplinesCurvenessThreshold_orig));
  free_string_field (&(args_info->checkSplinesLengthThreshold_orig));
  free_string_field (&(args_info->checkSplinesThetaDiffThreshold_orig));
  free_string_field (&(args_info->checkSplinesThetaThreshold_orig));
  free_string_field (&(args_info->checkIPMSplines_orig));
  free_string_field (&(args_info->checkIPMSplinesCurvenessThreshold_orig));
  free_string_field (&(args_info->checkIPMSplinesLengthThreshold_orig));
  free_string_field (&(args_info->checkIPMSplinesThetaDiffThreshold_orig));
  free_string_field (&(args_info->checkIPMSplinesThetaThreshold_orig));
  free_string_field (&(args_info->finalSplineScoreThreshold_orig));
  free_string_field (&(args_info->useGroundPlane_orig));
  free_string_field (&(args_info->checkColor_orig));
  free_string_field (&(args_info->checkColorWindow_orig));
  free_string_field (&(args_info->checkColorNumBins_orig));
  free_string_field (&(args_info->checkColorNumYellowMin_orig));
  free_string_field (&(args_info->checkColorRGMin_orig));
  free_string_field (&(args_info->checkColorRGMax_orig));
  free_string_field (&(args_info->checkColorGBMin_orig));
  free_string_field (&(args_info->checkColorRBMin_orig));
  free_string_field (&(args_info->checkColorRBFThreshold_orig));
  free_string_field (&(args_info->checkColorRBF_orig));
  free_string_field (&(args_info->ipmWindowClear_orig));
  free_string_field (&(args_info->ipmWindowLeft_orig));
  free_string_field (&(args_info->ipmWindowRight_orig));
  free_string_field (&(args_info->checkLaneWidth_orig));
  free_string_field (&(args_info->checkLaneWidthMean_orig));
  free_string_field (&(args_info->checkLaneWidthStd_orig));
  
  

  clear_given (args_info);
}


static void
write_into_file(FILE *outfile, const char *opt, const char *arg, const char *values[])
{
  FIX_UNUSED (values);
  if (arg) {
    fprintf(outfile, "%s=\"%s\"\n", opt, arg);
  } else {
    fprintf(outfile, "%s\n", opt);
  }
}


int
LaneDetectorParser_dump(FILE *outfile, struct LaneDetectorParserInfo *args_info)
{
  int i = 0;

  if (!outfile)
    {
      fprintf (stderr, "%s: cannot dump options to stream\n", LANEDETECTORPARSER_PACKAGE);
      return EXIT_FAILURE;
    }

  if (args_info->help_given)
    write_into_file(outfile, "help", 0, 0 );
  if (args_info->version_given)
    write_into_file(outfile, "version", 0, 0 );
  if (args_info->ipmWidth_given)
    write_into_file(outfile, "ipmWidth", args_info->ipmWidth_orig, 0);
  if (args_info->ipmHeight_given)
    write_into_file(outfile, "ipmHeight", args_info->ipmHeight_orig, 0);
  if (args_info->ipmTop_given)
    write_into_file(outfile, "ipmTop", args_info->ipmTop_orig, 0);
  if (args_info->ipmLeft_given)
    write_into_file(outfile, "ipmLeft", args_info->ipmLeft_orig, 0);
  if (args_info->ipmRight_given)
    write_into_file(outfile, "ipmRight", args_info->ipmRight_orig, 0);
  if (args_info->ipmBottom_given)
    write_into_file(outfile, "ipmBottom", args_info->ipmBottom_orig, 0);
  if (args_info->ipmInterpolation_given)
    write_into_file(outfile, "ipmInterpolation", args_info->ipmInterpolation_orig, 0);
  if (args_info->lineWidth_given)
    write_into_file(outfile, "lineWidth", args_info->lineWidth_orig, 0);
  if (args_info->lineHeight_given)
    write_into_file(outfile, "lineHeight", args_info->lineHeight_orig, 0);
  if (args_info->kernelWidth_given)
    write_into_file(outfile, "kernelWidth", args_info->kernelWidth_orig, 0);
  if (args_info->kernelHeight_given)
    write_into_file(outfile, "kernelHeight", args_info->kernelHeight_orig, 0);
  if (args_info->lowerQuantile_given)
    write_into_file(outfile, "lowerQuantile", args_info->lowerQuantile_orig, 0);
  if (args_info->localMaxima_given)
    write_into_file(outfile, "localMaxima", args_info->localMaxima_orig, 0);
  if (args_info->groupingType_given)
    write_into_file(outfile, "groupingType", args_info->groupingType_orig, 0);
  if (args_info->binarize_given)
    write_into_file(outfile, "binarize", args_info->binarize_orig, 0);
  if (args_info->detectionThreshold_given)
    write_into_file(outfile, "detectionThreshold", args_info->detectionThreshold_orig, 0);
  if (args_info->smoothScores_given)
    write_into_file(outfile, "smoothScores", args_info->smoothScores_orig, 0);
  if (args_info->rMin_given)
    write_into_file(outfile, "rMin", args_info->rMin_orig, 0);
  if (args_info->rMax_given)
    write_into_file(outfile, "rMax", args_info->rMax_orig, 0);
  if (args_info->rStep_given)
    write_into_file(outfile, "rStep", args_info->rStep_orig, 0);
  if (args_info->thetaMin_given)
    write_into_file(outfile, "thetaMin", args_info->thetaMin_orig, 0);
  if (args_info->thetaMax_given)
    write_into_file(outfile, "thetaMax", args_info->thetaMax_orig, 0);
  if (args_info->thetaStep_given)
    write_into_file(outfile, "thetaStep", args_info->thetaStep_orig, 0);
  if (args_info->ipmVpPortion_given)
    write_into_file(outfile, "ipmVpPortion", args_info->ipmVpPortion_orig, 0);
  if (args_info->getEndPoints_given)
    write_into_file(outfile, "getEndPoints", args_info->getEndPoints_orig, 0);
  if (args_info->group_given)
    write_into_file(outfile, "group", args_info->group_orig, 0);
  if (args_info->groupThreshold_given)
    write_into_file(outfile, "groupThreshold", args_info->groupThreshold_orig, 0);
  if (args_info->ransac_given)
    write_into_file(outfile, "ransac", args_info->ransac_orig, 0);
  if (args_info->ransacLineNumSamples_given)
    write_into_file(outfile, "ransacLineNumSamples", args_info->ransacLineNumSamples_orig, 0);
  if (args_info->ransacLineNumIterations_given)
    write_into_file(outfile, "ransacLineNumIterations", args_info->ransacLineNumIterations_orig, 0);
  if (args_info->ransacLineNumGoodFit_given)
    write_into_file(outfile, "ransacLineNumGoodFit", args_info->ransacLineNumGoodFit_orig, 0);
  if (args_info->ransacLineThreshold_given)
    write_into_file(outfile, "ransacLineThreshold", args_info->ransacLineThreshold_orig, 0);
  if (args_info->ransacLineScoreThreshold_given)
    write_into_file(outfile, "ransacLineScoreThreshold", args_info->ransacLineScoreThreshold_orig, 0);
  if (args_info->ransacLineBinarize_given)
    write_into_file(outfile, "ransacLineBinarize", args_info->ransacLineBinarize_orig, 0);
  if (args_info->ransacLineWindow_given)
    write_into_file(outfile, "ransacLineWindow", args_info->ransacLineWindow_orig, 0);
  if (args_info->ransacSplineNumSamples_given)
    write_into_file(outfile, "ransacSplineNumSamples", args_info->ransacSplineNumSamples_orig, 0);
  if (args_info->ransacSplineNumIterations_given)
    write_into_file(outfile, "ransacSplineNumIterations", args_info->ransacSplineNumIterations_orig, 0);
  if (args_info->ransacSplineNumGoodFit_given)
    write_into_file(outfile, "ransacSplineNumGoodFit", args_info->ransacSplineNumGoodFit_orig, 0);
  if (args_info->ransacSplineThreshold_given)
    write_into_file(outfile, "ransacSplineThreshold", args_info->ransacSplineThreshold_orig, 0);
  if (args_info->ransacSplineScoreThreshold_given)
    write_into_file(outfile, "ransacSplineScoreThreshold", args_info->ransacSplineScoreThreshold_orig, 0);
  if (args_info->ransacSplineBinarize_given)
    write_into_file(outfile, "ransacSplineBinarize", args_info->ransacSplineBinarize_orig, 0);
  if (args_info->ransacSplineWindow_given)
    write_into_file(outfile, "ransacSplineWindow", args_info->ransacSplineWindow_orig, 0);
  if (args_info->ransacSplineDegree_given)
    write_into_file(outfile, "ransacSplineDegree", args_info->ransacSplineDegree_orig, 0);
  if (args_info->ransacSpline_given)
    write_into_file(outfile, "ransacSpline", args_info->ransacSpline_orig, 0);
  if (args_info->ransacLine_given)
    write_into_file(outfile, "ransacLine", args_info->ransacLine_orig, 0);
  if (args_info->ransacSplineStep_given)
    write_into_file(outfile, "ransacSplineStep", args_info->ransacSplineStep_orig, 0);
  if (args_info->overlapThreshold_given)
    write_into_file(outfile, "overlapThreshold", args_info->overlapThreshold_orig, 0);
  if (args_info->localizeAngleThreshold_given)
    write_into_file(outfile, "localizeAngleThreshold", args_info->localizeAngleThreshold_orig, 0);
  if (args_info->localizeNumLinePixels_given)
    write_into_file(outfile, "localizeNumLinePixels", args_info->localizeNumLinePixels_orig, 0);
  if (args_info->extendAngleThreshold_given)
    write_into_file(outfile, "extendAngleThreshold", args_info->extendAngleThreshold_orig, 0);
  if (args_info->extendMeanDirAngleThreshold_given)
    write_into_file(outfile, "extendMeanDirAngleThreshold", args_info->extendMeanDirAngleThreshold_orig, 0);
  if (args_info->extendMeanDirAngleThresholdBack_given)
    write_into_file(outfile, "extendMeanDirAngleThresholdBack", args_info->extendMeanDirAngleThresholdBack_orig, 0);
  if (args_info->extendMeanDirAngleThresholdForward_given)
    write_into_file(outfile, "extendMeanDirAngleThresholdForward", args_info->extendMeanDirAngleThresholdForward_orig, 0);
  if (args_info->extendLinePixelsTangent_given)
    write_into_file(outfile, "extendLinePixelsTangent", args_info->extendLinePixelsTangent_orig, 0);
  if (args_info->extendLinePixelsNormal_given)
    write_into_file(outfile, "extendLinePixelsNormal", args_info->extendLinePixelsNormal_orig, 0);
  if (args_info->extendContThreshold_given)
    write_into_file(outfile, "extendContThreshold", args_info->extendContThreshold_orig, 0);
  if (args_info->extendDeviationThreshold_given)
    write_into_file(outfile, "extendDeviationThreshold", args_info->extendDeviationThreshold_orig, 0);
  if (args_info->extendRectTop_given)
    write_into_file(outfile, "extendRectTop", args_info->extendRectTop_orig, 0);
  if (args_info->extendRectBottom_given)
    write_into_file(outfile, "extendRectBottom", args_info->extendRectBottom_orig, 0);
  if (args_info->extendIPMAngleThreshold_given)
    write_into_file(outfile, "extendIPMAngleThreshold", args_info->extendIPMAngleThreshold_orig, 0);
  if (args_info->extendIPMMeanDirAngleThreshold_given)
    write_into_file(outfile, "extendIPMMeanDirAngleThreshold", args_info->extendIPMMeanDirAngleThreshold_orig, 0);
  if (args_info->extendIPMLinePixelsTangent_given)
    write_into_file(outfile, "extendIPMLinePixelsTangent", args_info->extendIPMLinePixelsTangent_orig, 0);
  if (args_info->extendIPMLinePixelsNormal_given)
    write_into_file(outfile, "extendIPMLinePixelsNormal", args_info->extendIPMLinePixelsNormal_orig, 0);
  if (args_info->extendIPMContThreshold_given)
    write_into_file(outfile, "extendIPMContThreshold", args_info->extendIPMContThreshold_orig, 0);
  if (args_info->extendIPMDeviationThreshold_given)
    write_into_file(outfile, "extendIPMDeviationThreshold", args_info->extendIPMDeviationThreshold_orig, 0);
  if (args_info->extendIPMRectTop_given)
    write_into_file(outfile, "extendIPMRectTop", args_info->extendIPMRectTop_orig, 0);
  if (args_info->extendIPMRectBottom_given)
    write_into_file(outfile, "extendIPMRectBottom", args_info->extendIPMRectBottom_orig, 0);
  if (args_info->splineScoreJitter_given)
    write_into_file(outfile, "splineScoreJitter", args_info->splineScoreJitter_orig, 0);
  if (args_info->splineScoreLengthRatio_given)
    write_into_file(outfile, "splineScoreLengthRatio", args_info->splineScoreLengthRatio_orig, 0);
  if (args_info->splineScoreAngleRatio_given)
    write_into_file(outfile, "splineScoreAngleRatio", args_info->splineScoreAngleRatio_orig, 0);
  if (args_info->splineScoreStep_given)
    write_into_file(outfile, "splineScoreStep", args_info->splineScoreStep_orig, 0);
  if (args_info->splineTrackingNumAbsentFrames_given)
    write_into_file(outfile, "splineTrackingNumAbsentFrames", args_info->splineTrackingNumAbsentFrames_orig, 0);
  if (args_info->splineTrackingNumSeenFrames_given)
    write_into_file(outfile, "splineTrackingNumSeenFrames", args_info->splineTrackingNumSeenFrames_orig, 0);
  if (args_info->mergeSplineThetaThreshold_given)
    write_into_file(outfile, "mergeSplineThetaThreshold", args_info->mergeSplineThetaThreshold_orig, 0);
  if (args_info->mergeSplineRThreshold_given)
    write_into_file(outfile, "mergeSplineRThreshold", args_info->mergeSplineRThreshold_orig, 0);
  if (args_info->mergeSplineMeanThetaThreshold_given)
    write_into_file(outfile, "mergeSplineMeanThetaThreshold", args_info->mergeSplineMeanThetaThreshold_orig, 0);
  if (args_info->mergeSplineMeanRThreshold_given)
    write_into_file(outfile, "mergeSplineMeanRThreshold", args_info->mergeSplineMeanRThreshold_orig, 0);
  if (args_info->mergeSplineCentroidThreshold_given)
    write_into_file(outfile, "mergeSplineCentroidThreshold", args_info->mergeSplineCentroidThreshold_orig, 0);
  if (args_info->lineTrackingNumAbsentFrames_given)
    write_into_file(outfile, "lineTrackingNumAbsentFrames", args_info->lineTrackingNumAbsentFrames_orig, 0);
  if (args_info->lineTrackingNumSeenFrames_given)
    write_into_file(outfile, "lineTrackingNumSeenFrames", args_info->lineTrackingNumSeenFrames_orig, 0);
  if (args_info->mergeLineThetaThreshold_given)
    write_into_file(outfile, "mergeLineThetaThreshold", args_info->mergeLineThetaThreshold_orig, 0);
  if (args_info->mergeLineRThreshold_given)
    write_into_file(outfile, "mergeLineRThreshold", args_info->mergeLineRThreshold_orig, 0);
  if (args_info->numStrips_given)
    write_into_file(outfile, "numStrips", args_info->numStrips_orig, 0);
  if (args_info->checkSplines_given)
    write_into_file(outfile, "checkSplines", args_info->checkSplines_orig, 0);
  if (args_info->checkSplinesCurvenessThreshold_given)
    write_into_file(outfile, "checkSplinesCurvenessThreshold", args_info->checkSplinesCurvenessThreshold_orig, 0);
  if (args_info->checkSplinesLengthThreshold_given)
    write_into_file(outfile, "checkSplinesLengthThreshold", args_info->checkSplinesLengthThreshold_orig, 0);
  if (args_info->checkSplinesThetaDiffThreshold_given)
    write_into_file(outfile, "checkSplinesThetaDiffThreshold", args_info->checkSplinesThetaDiffThreshold_orig, 0);
  if (args_info->checkSplinesThetaThreshold_given)
    write_into_file(outfile, "checkSplinesThetaThreshold", args_info->checkSplinesThetaThreshold_orig, 0);
  if (args_info->checkIPMSplines_given)
    write_into_file(outfile, "checkIPMSplines", args_info->checkIPMSplines_orig, 0);
  if (args_info->checkIPMSplinesCurvenessThreshold_given)
    write_into_file(outfile, "checkIPMSplinesCurvenessThreshold", args_info->checkIPMSplinesCurvenessThreshold_orig, 0);
  if (args_info->checkIPMSplinesLengthThreshold_given)
    write_into_file(outfile, "checkIPMSplinesLengthThreshold", args_info->checkIPMSplinesLengthThreshold_orig, 0);
  if (args_info->checkIPMSplinesThetaDiffThreshold_given)
    write_into_file(outfile, "checkIPMSplinesThetaDiffThreshold", args_info->checkIPMSplinesThetaDiffThreshold_orig, 0);
  if (args_info->checkIPMSplinesThetaThreshold_given)
    write_into_file(outfile, "checkIPMSplinesThetaThreshold", args_info->checkIPMSplinesThetaThreshold_orig, 0);
  if (args_info->finalSplineScoreThreshold_given)
    write_into_file(outfile, "finalSplineScoreThreshold", args_info->finalSplineScoreThreshold_orig, 0);
  if (args_info->useGroundPlane_given)
    write_into_file(outfile, "useGroundPlane", args_info->useGroundPlane_orig, 0);
  if (args_info->checkColor_given)
    write_into_file(outfile, "checkColor", args_info->checkColor_orig, 0);
  if (args_info->checkColorWindow_given)
    write_into_file(outfile, "checkColorWindow", args_info->checkColorWindow_orig, 0);
  if (args_info->checkColorNumBins_given)
    write_into_file(outfile, "checkColorNumBins", args_info->checkColorNumBins_orig, 0);
  if (args_info->checkColorNumYellowMin_given)
    write_into_file(outfile, "checkColorNumYellowMin", args_info->checkColorNumYellowMin_orig, 0);
  if (args_info->checkColorRGMin_given)
    write_into_file(outfile, "checkColorRGMin", args_info->checkColorRGMin_orig, 0);
  if (args_info->checkColorRGMax_given)
    write_into_file(outfile, "checkColorRGMax", args_info->checkColorRGMax_orig, 0);
  if (args_info->checkColorGBMin_given)
    write_into_file(outfile, "checkColorGBMin", args_info->checkColorGBMin_orig, 0);
  if (args_info->checkColorRBMin_given)
    write_into_file(outfile, "checkColorRBMin", args_info->checkColorRBMin_orig, 0);
  if (args_info->checkColorRBFThreshold_given)
    write_into_file(outfile, "checkColorRBFThreshold", args_info->checkColorRBFThreshold_orig, 0);
  if (args_info->checkColorRBF_given)
    write_into_file(outfile, "checkColorRBF", args_info->checkColorRBF_orig, 0);
  if (args_info->ipmWindowClear_given)
    write_into_file(outfile, "ipmWindowClear", args_info->ipmWindowClear_orig, 0);
  if (args_info->ipmWindowLeft_given)
    write_into_file(outfile, "ipmWindowLeft", args_info->ipmWindowLeft_orig, 0);
  if (args_info->ipmWindowRight_given)
    write_into_file(outfile, "ipmWindowRight", args_info->ipmWindowRight_orig, 0);
  if (args_info->checkLaneWidth_given)
    write_into_file(outfile, "checkLaneWidth", args_info->checkLaneWidth_orig, 0);
  if (args_info->checkLaneWidthMean_given)
    write_into_file(outfile, "checkLaneWidthMean", args_info->checkLaneWidthMean_orig, 0);
  if (args_info->checkLaneWidthStd_given)
    write_into_file(outfile, "checkLaneWidthStd", args_info->checkLaneWidthStd_orig, 0);
  

  i = EXIT_SUCCESS;
  return i;
}

int
LaneDetectorParser_file_save(const char *filename, struct LaneDetectorParserInfo *args_info)
{
  FILE *outfile;
  int i = 0;

  outfile = fopen(filename, "w");

  if (!outfile)
    {
      fprintf (stderr, "%s: cannot open file for writing: %s\n", LANEDETECTORPARSER_PACKAGE, filename);
      return EXIT_FAILURE;
    }

  i = LaneDetectorParser_dump(outfile, args_info);
  fclose (outfile);

  return i;
}

void
LaneDetectorParser_free (struct LaneDetectorParserInfo *args_info)
{
  LaneDetectorParser_release (args_info);
}

/** @brief replacement of strdup, which is not standard */
char *
gengetopt_strdup (const char *s)
{
  char *result = 0;
  if (!s)
    return result;

  result = (char*)malloc(strlen(s) + 1);
  if (result == (char*)0)
    return (char*)0;
  strcpy(result, s);
  return result;
}

int
LaneDetectorParser (int argc, char **argv, struct LaneDetectorParserInfo *args_info)
{
  return LaneDetectorParser2 (argc, argv, args_info, 0, 1, 1);
}

int
LaneDetectorParser_ext (int argc, char **argv, struct LaneDetectorParserInfo *args_info,
                   struct LaneDetectorParser_params *params)
{
  int result;
  result = LaneDetectorParser_internal (argc, argv, args_info, params, 0);

  if (result == EXIT_FAILURE)
    {
      LaneDetectorParser_free (args_info);
      exit (EXIT_FAILURE);
    }
  
  return result;
}

int
LaneDetectorParser2 (int argc, char **argv, struct LaneDetectorParserInfo *args_info, int override, int initialize, int check_required)
{
  int result;
  struct LaneDetectorParser_params params;
  
  params.override = override;
  params.initialize = initialize;
  params.check_required = check_required;
  params.check_ambiguity = 0;
  params.print_errors = 1;

  result = LaneDetectorParser_internal (argc, argv, args_info, &params, 0);

  if (result == EXIT_FAILURE)
    {
      LaneDetectorParser_free (args_info);
      exit (EXIT_FAILURE);
    }
  
  return result;
}

int
LaneDetectorParser_required (struct LaneDetectorParserInfo *args_info, const char *prog_name)
{
  int result = EXIT_SUCCESS;

  if (LaneDetectorParser_required2(args_info, prog_name, 0) > 0)
    result = EXIT_FAILURE;

  if (result == EXIT_FAILURE)
    {
      LaneDetectorParser_free (args_info);
      exit (EXIT_FAILURE);
    }
  
  return result;
}

int
LaneDetectorParser_required2 (struct LaneDetectorParserInfo *args_info, const char *prog_name, const char *additional_error)
{
  int error_occurred = 0;
  FIX_UNUSED (additional_error);

  /* checks for required options */
  if (! args_info->ipmWidth_given)
    {
      fprintf (stderr, "%s: '--ipmWidth' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error_occurred = 1;
    }
  
  if (! args_info->ipmHeight_given)
    {
      fprintf (stderr, "%s: '--ipmHeight' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error_occurred = 1;
    }
  
  if (! args_info->ipmTop_given)
    {
      fprintf (stderr, "%s: '--ipmTop' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error_occurred = 1;
    }
  
  if (! args_info->ipmLeft_given)
    {
      fprintf (stderr, "%s: '--ipmLeft' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error_occurred = 1;
    }
  
  if (! args_info->ipmRight_given)
    {
      fprintf (stderr, "%s: '--ipmRight' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error_occurred = 1;
    }
  
  if (! args_info->ipmBottom_given)
    {
      fprintf (stderr, "%s: '--ipmBottom' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error_occurred = 1;
    }
  
  if (! args_info->ipmInterpolation_given)
    {
      fprintf (stderr, "%s: '--ipmInterpolation' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error_occurred = 1;
    }
  
  if (! args_info->lineWidth_given)
    {
      fprintf (stderr, "%s: '--lineWidth' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error_occurred = 1;
    }
  
  if (! args_info->lineHeight_given)
    {
      fprintf (stderr, "%s: '--lineHeight' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error_occurred = 1;
    }
  
  if (! args_info->kernelWidth_given)
    {
      fprintf (stderr, "%s: '--kernelWidth' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error_occurred = 1;
    }
  
  if (! args_info->kernelHeight_given)
    {
      fprintf (stderr, "%s: '--kernelHeight' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error_occurred = 1;
    }
  
  if (! args_info->lowerQuantile_given)
    {
      fprintf (stderr, "%s: '--lowerQuantile' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error_occurred = 1;
    }
  
  if (! args_info->localMaxima_given)
    {
      fprintf (stderr, "%s: '--localMaxima' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error_occurred = 1;
    }
  
  if (! args_info->groupingType_given)
    {
      fprintf (stderr, "%s: '--groupingType' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error_occurred = 1;
    }
  
  if (! args_info->binarize_given)
    {
      fprintf (stderr, "%s: '--binarize' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error_occurred = 1;
    }
  
  if (! args_info->detectionThreshold_given)
    {
      fprintf (stderr, "%s: '--detectionThreshold' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error_occurred = 1;
    }
  
  if (! args_info->smoothScores_given)
    {
      fprintf (stderr, "%s: '--smoothScores' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error_occurred = 1;
    }
  
  if (! args_info->rMin_given)
    {
      fprintf (stderr, "%s: '--rMin' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error_occurred = 1;
    }
  
  if (! args_info->rMax_given)
    {
      fprintf (stderr, "%s: '--rMax' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error_occurred = 1;
    }
  
  if (! args_info->rStep_given)
    {
      fprintf (stderr, "%s: '--rStep' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error_occurred = 1;
    }
  
  if (! args_info->thetaMin_given)
    {
      fprintf (stderr, "%s: '--thetaMin' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error_occurred = 1;
    }
  
  if (! args_info->thetaMax_given)
    {
      fprintf (stderr, "%s: '--thetaMax' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error_occurred = 1;
    }
  
  if (! args_info->thetaStep_given)
    {
      fprintf (stderr, "%s: '--thetaStep' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error_occurred = 1;
    }
  
  if (! args_info->ipmVpPortion_given)
    {
      fprintf (stderr, "%s: '--ipmVpPortion' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error_occurred = 1;
    }
  
  if (! args_info->getEndPoints_given)
    {
      fprintf (stderr, "%s: '--getEndPoints' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error_occurred = 1;
    }
  
  if (! args_info->group_given)
    {
      fprintf (stderr, "%s: '--group' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error_occurred = 1;
    }
  
  if (! args_info->groupThreshold_given)
    {
      fprintf (stderr, "%s: '--groupThreshold' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error_occurred = 1;
    }
  
  if (! args_info->ransac_given)
    {
      fprintf (stderr, "%s: '--ransac' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error_occurred = 1;
    }
  
  if (! args_info->ransacLineNumSamples_given)
    {
      fprintf (stderr, "%s: '--ransacLineNumSamples' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error_occurred = 1;
    }
  
  if (! args_info->ransacLineNumIterations_given)
    {
      fprintf (stderr, "%s: '--ransacLineNumIterations' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error_occurred = 1;
    }
  
  if (! args_info->ransacLineNumGoodFit_given)
    {
      fprintf (stderr, "%s: '--ransacLineNumGoodFit' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error_occurred = 1;
    }
  
  if (! args_info->ransacLineThreshold_given)
    {
      fprintf (stderr, "%s: '--ransacLineThreshold' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error_occurred = 1;
    }
  
  if (! args_info->ransacLineScoreThreshold_given)
    {
      fprintf (stderr, "%s: '--ransacLineScoreThreshold' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error_occurred = 1;
    }
  
  if (! args_info->ransacLineBinarize_given)
    {
      fprintf (stderr, "%s: '--ransacLineBinarize' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error_occurred = 1;
    }
  
  if (! args_info->ransacLineWindow_given)
    {
      fprintf (stderr, "%s: '--ransacLineWindow' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error_occurred = 1;
    }
  
  if (! args_info->ransacSplineNumSamples_given)
    {
      fprintf (stderr, "%s: '--ransacSplineNumSamples' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error_occurred = 1;
    }
  
  if (! args_info->ransacSplineNumIterations_given)
    {
      fprintf (stderr, "%s: '--ransacSplineNumIterations' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error_occurred = 1;
    }
  
  if (! args_info->ransacSplineNumGoodFit_given)
    {
      fprintf (stderr, "%s: '--ransacSplineNumGoodFit' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error_occurred = 1;
    }
  
  if (! args_info->ransacSplineThreshold_given)
    {
      fprintf (stderr, "%s: '--ransacSplineThreshold' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error_occurred = 1;
    }
  
  if (! args_info->ransacSplineScoreThreshold_given)
    {
      fprintf (stderr, "%s: '--ransacSplineScoreThreshold' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error_occurred = 1;
    }
  
  if (! args_info->ransacSplineBinarize_given)
    {
      fprintf (stderr, "%s: '--ransacSplineBinarize' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error_occurred = 1;
    }
  
  if (! args_info->ransacSplineWindow_given)
    {
      fprintf (stderr, "%s: '--ransacSplineWindow' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error_occurred = 1;
    }
  
  if (! args_info->ransacSplineDegree_given)
    {
      fprintf (stderr, "%s: '--ransacSplineDegree' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error_occurred = 1;
    }
  
  if (! args_info->ransacSpline_given)
    {
      fprintf (stderr, "%s: '--ransacSpline' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error_occurred = 1;
    }
  
  if (! args_info->ransacLine_given)
    {
      fprintf (stderr, "%s: '--ransacLine' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error_occurred = 1;
    }
  
  if (! args_info->ransacSplineStep_given)
    {
      fprintf (stderr, "%s: '--ransacSplineStep' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error_occurred = 1;
    }
  
  if (! args_info->overlapThreshold_given)
    {
      fprintf (stderr, "%s: '--overlapThreshold' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error_occurred = 1;
    }
  
  if (! args_info->localizeAngleThreshold_given)
    {
      fprintf (stderr, "%s: '--localizeAngleThreshold' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error_occurred = 1;
    }
  
  if (! args_info->localizeNumLinePixels_given)
    {
      fprintf (stderr, "%s: '--localizeNumLinePixels' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error_occurred = 1;
    }
  
  if (! args_info->extendAngleThreshold_given)
    {
      fprintf (stderr, "%s: '--extendAngleThreshold' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error_occurred = 1;
    }
  
  if (! args_info->extendMeanDirAngleThreshold_given)
    {
      fprintf (stderr, "%s: '--extendMeanDirAngleThreshold' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error_occurred = 1;
    }
  
  if (! args_info->extendMeanDirAngleThresholdBack_given)
    {
      fprintf (stderr, "%s: '--extendMeanDirAngleThresholdBack' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error_occurred = 1;
    }
  
  if (! args_info->extendMeanDirAngleThresholdForward_given)
    {
      fprintf (stderr, "%s: '--extendMeanDirAngleThresholdForward' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error_occurred = 1;
    }
  
  if (! args_info->extendLinePixelsTangent_given)
    {
      fprintf (stderr, "%s: '--extendLinePixelsTangent' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error_occurred = 1;
    }
  
  if (! args_info->extendLinePixelsNormal_given)
    {
      fprintf (stderr, "%s: '--extendLinePixelsNormal' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error_occurred = 1;
    }
  
  if (! args_info->extendContThreshold_given)
    {
      fprintf (stderr, "%s: '--extendContThreshold' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error_occurred = 1;
    }
  
  if (! args_info->extendDeviationThreshold_given)
    {
      fprintf (stderr, "%s: '--extendDeviationThreshold' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error_occurred = 1;
    }
  
  if (! args_info->extendRectTop_given)
    {
      fprintf (stderr, "%s: '--extendRectTop' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error_occurred = 1;
    }
  
  if (! args_info->extendRectBottom_given)
    {
      fprintf (stderr, "%s: '--extendRectBottom' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error_occurred = 1;
    }
  
  if (! args_info->extendIPMAngleThreshold_given)
    {
      fprintf (stderr, "%s: '--extendIPMAngleThreshold' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error_occurred = 1;
    }
  
  if (! args_info->extendIPMMeanDirAngleThreshold_given)
    {
      fprintf (stderr, "%s: '--extendIPMMeanDirAngleThreshold' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error_occurred = 1;
    }
  
  if (! args_info->extendIPMLinePixelsTangent_given)
    {
      fprintf (stderr, "%s: '--extendIPMLinePixelsTangent' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error_occurred = 1;
    }
  
  if (! args_info->extendIPMLinePixelsNormal_given)
    {
      fprintf (stderr, "%s: '--extendIPMLinePixelsNormal' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error_occurred = 1;
    }
  
  if (! args_info->extendIPMContThreshold_given)
    {
      fprintf (stderr, "%s: '--extendIPMContThreshold' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error_occurred = 1;
    }
  
  if (! args_info->extendIPMDeviationThreshold_given)
    {
      fprintf (stderr, "%s: '--extendIPMDeviationThreshold' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error_occurred = 1;
    }
  
  if (! args_info->extendIPMRectTop_given)
    {
      fprintf (stderr, "%s: '--extendIPMRectTop' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error_occurred = 1;
    }
  
  if (! args_info->extendIPMRectBottom_given)
    {
      fprintf (stderr, "%s: '--extendIPMRectBottom' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error_occurred = 1;
    }
  
  if (! args_info->splineScoreJitter_given)
    {
      fprintf (stderr, "%s: '--splineScoreJitter' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error_occurred = 1;
    }
  
  if (! args_info->splineScoreLengthRatio_given)
    {
      fprintf (stderr, "%s: '--splineScoreLengthRatio' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error_occurred = 1;
    }
  
  if (! args_info->splineScoreAngleRatio_given)
    {
      fprintf (stderr, "%s: '--splineScoreAngleRatio' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error_occurred = 1;
    }
  
  if (! args_info->splineScoreStep_given)
    {
      fprintf (stderr, "%s: '--splineScoreStep' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error_occurred = 1;
    }
  
  if (! args_info->splineTrackingNumAbsentFrames_given)
    {
      fprintf (stderr, "%s: '--splineTrackingNumAbsentFrames' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error_occurred = 1;
    }
  
  if (! args_info->splineTrackingNumSeenFrames_given)
    {
      fprintf (stderr, "%s: '--splineTrackingNumSeenFrames' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error_occurred = 1;
    }
  
  if (! args_info->mergeSplineThetaThreshold_given)
    {
      fprintf (stderr, "%s: '--mergeSplineThetaThreshold' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error_occurred = 1;
    }
  
  if (! args_info->mergeSplineRThreshold_given)
    {
      fprintf (stderr, "%s: '--mergeSplineRThreshold' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error_occurred = 1;
    }
  
  if (! args_info->mergeSplineMeanThetaThreshold_given)
    {
      fprintf (stderr, "%s: '--mergeSplineMeanThetaThreshold' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error_occurred = 1;
    }
  
  if (! args_info->mergeSplineMeanRThreshold_given)
    {
      fprintf (stderr, "%s: '--mergeSplineMeanRThreshold' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error_occurred = 1;
    }
  
  if (! args_info->mergeSplineCentroidThreshold_given)
    {
      fprintf (stderr, "%s: '--mergeSplineCentroidThreshold' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error_occurred = 1;
    }
  
  if (! args_info->lineTrackingNumAbsentFrames_given)
    {
      fprintf (stderr, "%s: '--lineTrackingNumAbsentFrames' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error_occurred = 1;
    }
  
  if (! args_info->lineTrackingNumSeenFrames_given)
    {
      fprintf (stderr, "%s: '--lineTrackingNumSeenFrames' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error_occurred = 1;
    }
  
  if (! args_info->mergeLineThetaThreshold_given)
    {
      fprintf (stderr, "%s: '--mergeLineThetaThreshold' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error_occurred = 1;
    }
  
  if (! args_info->mergeLineRThreshold_given)
    {
      fprintf (stderr, "%s: '--mergeLineRThreshold' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error_occurred = 1;
    }
  
  if (! args_info->numStrips_given)
    {
      fprintf (stderr, "%s: '--numStrips' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error_occurred = 1;
    }
  
  if (! args_info->checkSplines_given)
    {
      fprintf (stderr, "%s: '--checkSplines' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error_occurred = 1;
    }
  
  if (! args_info->checkSplinesCurvenessThreshold_given)
    {
      fprintf (stderr, "%s: '--checkSplinesCurvenessThreshold' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error_occurred = 1;
    }
  
  if (! args_info->checkSplinesLengthThreshold_given)
    {
      fprintf (stderr, "%s: '--checkSplinesLengthThreshold' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error_occurred = 1;
    }
  
  if (! args_info->checkSplinesThetaDiffThreshold_given)
    {
      fprintf (stderr, "%s: '--checkSplinesThetaDiffThreshold' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error_occurred = 1;
    }
  
  if (! args_info->checkSplinesThetaThreshold_given)
    {
      fprintf (stderr, "%s: '--checkSplinesThetaThreshold' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error_occurred = 1;
    }
  
  if (! args_info->checkIPMSplines_given)
    {
      fprintf (stderr, "%s: '--checkIPMSplines' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error_occurred = 1;
    }
  
  if (! args_info->checkIPMSplinesCurvenessThreshold_given)
    {
      fprintf (stderr, "%s: '--checkIPMSplinesCurvenessThreshold' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error_occurred = 1;
    }
  
  if (! args_info->checkIPMSplinesLengthThreshold_given)
    {
      fprintf (stderr, "%s: '--checkIPMSplinesLengthThreshold' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error_occurred = 1;
    }
  
  if (! args_info->checkIPMSplinesThetaDiffThreshold_given)
    {
      fprintf (stderr, "%s: '--checkIPMSplinesThetaDiffThreshold' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error_occurred = 1;
    }
  
  if (! args_info->checkIPMSplinesThetaThreshold_given)
    {
      fprintf (stderr, "%s: '--checkIPMSplinesThetaThreshold' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error_occurred = 1;
    }
  
  if (! args_info->finalSplineScoreThreshold_given)
    {
      fprintf (stderr, "%s: '--finalSplineScoreThreshold' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error_occurred = 1;
    }
  
  if (! args_info->useGroundPlane_given)
    {
      fprintf (stderr, "%s: '--useGroundPlane' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error_occurred = 1;
    }
  
  if (! args_info->checkColor_given)
    {
      fprintf (stderr, "%s: '--checkColor' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error_occurred = 1;
    }
  
  if (! args_info->checkColorWindow_given)
    {
      fprintf (stderr, "%s: '--checkColorWindow' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error_occurred = 1;
    }
  
  if (! args_info->checkColorNumBins_given)
    {
      fprintf (stderr, "%s: '--checkColorNumBins' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error_occurred = 1;
    }
  
  if (! args_info->checkColorNumYellowMin_given)
    {
      fprintf (stderr, "%s: '--checkColorNumYellowMin' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error_occurred = 1;
    }
  
  if (! args_info->checkColorRGMin_given)
    {
      fprintf (stderr, "%s: '--checkColorRGMin' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error_occurred = 1;
    }
  
  if (! args_info->checkColorRGMax_given)
    {
      fprintf (stderr, "%s: '--checkColorRGMax' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error_occurred = 1;
    }
  
  if (! args_info->checkColorGBMin_given)
    {
      fprintf (stderr, "%s: '--checkColorGBMin' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error_occurred = 1;
    }
  
  if (! args_info->checkColorRBMin_given)
    {
      fprintf (stderr, "%s: '--checkColorRBMin' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error_occurred = 1;
    }
  
  if (! args_info->checkColorRBFThreshold_given)
    {
      fprintf (stderr, "%s: '--checkColorRBFThreshold' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error_occurred = 1;
    }
  
  if (! args_info->checkColorRBF_given)
    {
      fprintf (stderr, "%s: '--checkColorRBF' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error_occurred = 1;
    }
  
  if (! args_info->ipmWindowClear_given)
    {
      fprintf (stderr, "%s: '--ipmWindowClear' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error_occurred = 1;
    }
  
  if (! args_info->ipmWindowLeft_given)
    {
      fprintf (stderr, "%s: '--ipmWindowLeft' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error_occurred = 1;
    }
  
  if (! args_info->ipmWindowRight_given)
    {
      fprintf (stderr, "%s: '--ipmWindowRight' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error_occurred = 1;
    }
  
  if (! args_info->checkLaneWidth_given)
    {
      fprintf (stderr, "%s: '--checkLaneWidth' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error_occurred = 1;
    }
  
  if (! args_info->checkLaneWidthMean_given)
    {
      fprintf (stderr, "%s: '--checkLaneWidthMean' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error_occurred = 1;
    }
  
  if (! args_info->checkLaneWidthStd_given)
    {
      fprintf (stderr, "%s: '--checkLaneWidthStd' option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error_occurred = 1;
    }
  
  
  /* checks for dependences among options */

  return error_occurred;
}


static char *package_name = 0;

/**
 * @brief updates an option
 * @param field the generic pointer to the field to update
 * @param orig_field the pointer to the orig field
 * @param field_given the pointer to the number of occurrence of this option
 * @param prev_given the pointer to the number of occurrence already seen
 * @param value the argument for this option (if null no arg was specified)
 * @param possible_values the possible values for this option (if specified)
 * @param default_value the default value (in case the option only accepts fixed values)
 * @param arg_type the type of this option
 * @param check_ambiguity @see LaneDetectorParser_params.check_ambiguity
 * @param override @see LaneDetectorParser_params.override
 * @param no_free whether to free a possible previous value
 * @param multiple_option whether this is a multiple option
 * @param long_opt the corresponding long option
 * @param short_opt the corresponding short option (or '-' if none)
 * @param additional_error possible further error specification
 */
static
int update_arg(void *field, char **orig_field,
               unsigned int *field_given, unsigned int *prev_given, 
               char *value, const char *possible_values[],
               const char *default_value,
               LaneDetectorParser_arg_type arg_type,
               int check_ambiguity, int override,
               int no_free, int multiple_option,
               const char *long_opt, char short_opt,
               const char *additional_error)
{
  char *stop_char = 0;
  const char *val = value;
  int found;
  FIX_UNUSED (field);

  stop_char = 0;
  found = 0;

  if (!multiple_option && prev_given && (*prev_given || (check_ambiguity && *field_given)))
    {
      if (short_opt != '-')
        fprintf (stderr, "%s: `--%s' (`-%c') option given more than once%s\n", 
               package_name, long_opt, short_opt,
               (additional_error ? additional_error : ""));
      else
        fprintf (stderr, "%s: `--%s' option given more than once%s\n", 
               package_name, long_opt,
               (additional_error ? additional_error : ""));
      return 1; /* failure */
    }

  FIX_UNUSED (default_value);
    
  if (field_given && *field_given && ! override)
    return 0;
  if (prev_given)
    (*prev_given)++;
  if (field_given)
    (*field_given)++;
  if (possible_values)
    val = possible_values[found];

  switch(arg_type) {
  case ARG_INT:
    if (val) *((int *)field) = strtol (val, &stop_char, 0);
    break;
  case ARG_FLOAT:
    if (val) *((float *)field) = (float)strtod (val, &stop_char);
    break;
  case ARG_DOUBLE:
    if (val) *((double *)field) = strtod (val, &stop_char);
    break;
  default:
    break;
  };

  /* check numeric conversion */
  switch(arg_type) {
  case ARG_INT:
  case ARG_FLOAT:
  case ARG_DOUBLE:
    if (val && !(stop_char && *stop_char == '\0')) {
      fprintf(stderr, "%s: invalid numeric value: %s\n", package_name, val);
      return 1; /* failure */
    }
    break;
  default:
    ;
  };

  /* store the original value */
  switch(arg_type) {
  case ARG_NO:
    break;
  default:
    if (value && orig_field) {
      if (no_free) {
        *orig_field = value;
      } else {
        if (*orig_field)
          free (*orig_field); /* free previous string */
        *orig_field = gengetopt_strdup (value);
      }
    }
  };

  return 0; /* OK */
}


int
LaneDetectorParser_internal (
  int argc, char **argv, struct LaneDetectorParserInfo *args_info,
                        struct LaneDetectorParser_params *params, const char *additional_error)
{
  int c;	/* Character of the parsed option.  */

  int error_occurred = 0;
  struct LaneDetectorParserInfo local_args_info;
  
  int override;
  int initialize;
  int check_required;
  int check_ambiguity;
  
  package_name = argv[0];
  
  override = params->override;
  initialize = params->initialize;
  check_required = params->check_required;
  check_ambiguity = params->check_ambiguity;

  if (initialize)
    LaneDetectorParser_init (args_info);

  LaneDetectorParser_init (&local_args_info);

  optarg = 0;
  optind = 0;
  opterr = params->print_errors;
  optopt = '?';

  while (1)
    {
      int option_index = 0;

      static struct option long_options[] = {
        { "help",	0, NULL, 'h' },
        { "version",	0, NULL, 'V' },
        { "ipmWidth",	1, NULL, 0 },
        { "ipmHeight",	1, NULL, 0 },
        { "ipmTop",	1, NULL, 0 },
        { "ipmLeft",	1, NULL, 0 },
        { "ipmRight",	1, NULL, 0 },
        { "ipmBottom",	1, NULL, 0 },
        { "ipmInterpolation",	1, NULL, 0 },
        { "lineWidth",	1, NULL, 0 },
        { "lineHeight",	1, NULL, 0 },
        { "kernelWidth",	1, NULL, 0 },
        { "kernelHeight",	1, NULL, 0 },
        { "lowerQuantile",	1, NULL, 0 },
        { "localMaxima",	1, NULL, 0 },
        { "groupingType",	1, NULL, 0 },
        { "binarize",	1, NULL, 0 },
        { "detectionThreshold",	1, NULL, 0 },
        { "smoothScores",	1, NULL, 0 },
        { "rMin",	1, NULL, 0 },
        { "rMax",	1, NULL, 0 },
        { "rStep",	1, NULL, 0 },
        { "thetaMin",	1, NULL, 0 },
        { "thetaMax",	1, NULL, 0 },
        { "thetaStep",	1, NULL, 0 },
        { "ipmVpPortion",	1, NULL, 0 },
        { "getEndPoints",	1, NULL, 0 },
        { "group",	1, NULL, 0 },
        { "groupThreshold",	1, NULL, 0 },
        { "ransac",	1, NULL, 0 },
        { "ransacLineNumSamples",	1, NULL, 0 },
        { "ransacLineNumIterations",	1, NULL, 0 },
        { "ransacLineNumGoodFit",	1, NULL, 0 },
        { "ransacLineThreshold",	1, NULL, 0 },
        { "ransacLineScoreThreshold",	1, NULL, 0 },
        { "ransacLineBinarize",	1, NULL, 0 },
        { "ransacLineWindow",	1, NULL, 0 },
        { "ransacSplineNumSamples",	1, NULL, 0 },
        { "ransacSplineNumIterations",	1, NULL, 0 },
        { "ransacSplineNumGoodFit",	1, NULL, 0 },
        { "ransacSplineThreshold",	1, NULL, 0 },
        { "ransacSplineScoreThreshold",	1, NULL, 0 },
        { "ransacSplineBinarize",	1, NULL, 0 },
        { "ransacSplineWindow",	1, NULL, 0 },
        { "ransacSplineDegree",	1, NULL, 0 },
        { "ransacSpline",	1, NULL, 0 },
        { "ransacLine",	1, NULL, 0 },
        { "ransacSplineStep",	1, NULL, 0 },
        { "overlapThreshold",	1, NULL, 0 },
        { "localizeAngleThreshold",	1, NULL, 0 },
        { "localizeNumLinePixels",	1, NULL, 0 },
        { "extendAngleThreshold",	1, NULL, 0 },
        { "extendMeanDirAngleThreshold",	1, NULL, 0 },
        { "extendMeanDirAngleThresholdBack",	1, NULL, 0 },
        { "extendMeanDirAngleThresholdForward",	1, NULL, 0 },
        { "extendLinePixelsTangent",	1, NULL, 0 },
        { "extendLinePixelsNormal",	1, NULL, 0 },
        { "extendContThreshold",	1, NULL, 0 },
        { "extendDeviationThreshold",	1, NULL, 0 },
        { "extendRectTop",	1, NULL, 0 },
        { "extendRectBottom",	1, NULL, 0 },
        { "extendIPMAngleThreshold",	1, NULL, 0 },
        { "extendIPMMeanDirAngleThreshold",	1, NULL, 0 },
        { "extendIPMLinePixelsTangent",	1, NULL, 0 },
        { "extendIPMLinePixelsNormal",	1, NULL, 0 },
        { "extendIPMContThreshold",	1, NULL, 0 },
        { "extendIPMDeviationThreshold",	1, NULL, 0 },
        { "extendIPMRectTop",	1, NULL, 0 },
        { "extendIPMRectBottom",	1, NULL, 0 },
        { "splineScoreJitter",	1, NULL, 0 },
        { "splineScoreLengthRatio",	1, NULL, 0 },
        { "splineScoreAngleRatio",	1, NULL, 0 },
        { "splineScoreStep",	1, NULL, 0 },
        { "splineTrackingNumAbsentFrames",	1, NULL, 0 },
        { "splineTrackingNumSeenFrames",	1, NULL, 0 },
        { "mergeSplineThetaThreshold",	1, NULL, 0 },
        { "mergeSplineRThreshold",	1, NULL, 0 },
        { "mergeSplineMeanThetaThreshold",	1, NULL, 0 },
        { "mergeSplineMeanRThreshold",	1, NULL, 0 },
        { "mergeSplineCentroidThreshold",	1, NULL, 0 },
        { "lineTrackingNumAbsentFrames",	1, NULL, 0 },
        { "lineTrackingNumSeenFrames",	1, NULL, 0 },
        { "mergeLineThetaThreshold",	1, NULL, 0 },
        { "mergeLineRThreshold",	1, NULL, 0 },
        { "numStrips",	1, NULL, 0 },
        { "checkSplines",	1, NULL, 0 },
        { "checkSplinesCurvenessThreshold",	1, NULL, 0 },
        { "checkSplinesLengthThreshold",	1, NULL, 0 },
        { "checkSplinesThetaDiffThreshold",	1, NULL, 0 },
        { "checkSplinesThetaThreshold",	1, NULL, 0 },
        { "checkIPMSplines",	1, NULL, 0 },
        { "checkIPMSplinesCurvenessThreshold",	1, NULL, 0 },
        { "checkIPMSplinesLengthThreshold",	1, NULL, 0 },
        { "checkIPMSplinesThetaDiffThreshold",	1, NULL, 0 },
        { "checkIPMSplinesThetaThreshold",	1, NULL, 0 },
        { "finalSplineScoreThreshold",	1, NULL, 0 },
        { "useGroundPlane",	1, NULL, 0 },
        { "checkColor",	1, NULL, 0 },
        { "checkColorWindow",	1, NULL, 0 },
        { "checkColorNumBins",	1, NULL, 0 },
        { "checkColorNumYellowMin",	1, NULL, 0 },
        { "checkColorRGMin",	1, NULL, 0 },
        { "checkColorRGMax",	1, NULL, 0 },
        { "checkColorGBMin",	1, NULL, 0 },
        { "checkColorRBMin",	1, NULL, 0 },
        { "checkColorRBFThreshold",	1, NULL, 0 },
        { "checkColorRBF",	1, NULL, 0 },
        { "ipmWindowClear",	1, NULL, 0 },
        { "ipmWindowLeft",	1, NULL, 0 },
        { "ipmWindowRight",	1, NULL, 0 },
        { "checkLaneWidth",	1, NULL, 0 },
        { "checkLaneWidthMean",	1, NULL, 0 },
        { "checkLaneWidthStd",	1, NULL, 0 },
        { 0,  0, 0, 0 }
      };

      c = getopt_long (argc, argv, "hV", long_options, &option_index);

      if (c == -1) break;	/* Exit from `while (1)' loop.  */

      switch (c)
        {
        case 'h':	/* Print help and exit.  */
          LaneDetectorParser_print_help ();
          LaneDetectorParser_free (&local_args_info);
          exit (EXIT_SUCCESS);

        case 'V':	/* Print version and exit.  */
          LaneDetectorParser_print_version ();
          LaneDetectorParser_free (&local_args_info);
          exit (EXIT_SUCCESS);


        case 0:	/* Long option with no short option */
          /* width of IPM image to use.  */
          if (strcmp (long_options[option_index].name, "ipmWidth") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->ipmWidth_arg), 
                 &(args_info->ipmWidth_orig), &(args_info->ipmWidth_given),
                &(local_args_info.ipmWidth_given), optarg, 0, 0, ARG_INT,
                check_ambiguity, override, 0, 0,
                "ipmWidth", '-',
                additional_error))
              goto failure;
          
          }
          /* height of IPM image to use.  */
          else if (strcmp (long_options[option_index].name, "ipmHeight") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->ipmHeight_arg), 
                 &(args_info->ipmHeight_orig), &(args_info->ipmHeight_given),
                &(local_args_info.ipmHeight_given), optarg, 0, 0, ARG_INT,
                check_ambiguity, override, 0, 0,
                "ipmHeight", '-',
                additional_error))
              goto failure;
          
          }
          /* Top point in original image of region to make IPM for.  */
          else if (strcmp (long_options[option_index].name, "ipmTop") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->ipmTop_arg), 
                 &(args_info->ipmTop_orig), &(args_info->ipmTop_given),
                &(local_args_info.ipmTop_given), optarg, 0, 0, ARG_INT,
                check_ambiguity, override, 0, 0,
                "ipmTop", '-',
                additional_error))
              goto failure;
          
          }
          /* Left point in original image of region to make IPM for.  */
          else if (strcmp (long_options[option_index].name, "ipmLeft") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->ipmLeft_arg), 
                 &(args_info->ipmLeft_orig), &(args_info->ipmLeft_given),
                &(local_args_info.ipmLeft_given), optarg, 0, 0, ARG_INT,
                check_ambiguity, override, 0, 0,
                "ipmLeft", '-',
                additional_error))
              goto failure;
          
          }
          /* Right point in original image region to make IPM for.  */
          else if (strcmp (long_options[option_index].name, "ipmRight") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->ipmRight_arg), 
                 &(args_info->ipmRight_orig), &(args_info->ipmRight_given),
                &(local_args_info.ipmRight_given), optarg, 0, 0, ARG_INT,
                check_ambiguity, override, 0, 0,
                "ipmRight", '-',
                additional_error))
              goto failure;
          
          }
          /* Bottom point in original image region to make IPM for.  */
          else if (strcmp (long_options[option_index].name, "ipmBottom") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->ipmBottom_arg), 
                 &(args_info->ipmBottom_orig), &(args_info->ipmBottom_given),
                &(local_args_info.ipmBottom_given), optarg, 0, 0, ARG_INT,
                check_ambiguity, override, 0, 0,
                "ipmBottom", '-',
                additional_error))
              goto failure;
          
          }
          /* The method to use for IPM interpolation.  */
          else if (strcmp (long_options[option_index].name, "ipmInterpolation") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->ipmInterpolation_arg), 
                 &(args_info->ipmInterpolation_orig), &(args_info->ipmInterpolation_given),
                &(local_args_info.ipmInterpolation_given), optarg, 0, 0, ARG_INT,
                check_ambiguity, override, 0, 0,
                "ipmInterpolation", '-',
                additional_error))
              goto failure;
          
          }
          /* width of line to detect in mm (in the world).  */
          else if (strcmp (long_options[option_index].name, "lineWidth") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->lineWidth_arg), 
                 &(args_info->lineWidth_orig), &(args_info->lineWidth_given),
                &(local_args_info.lineWidth_given), optarg, 0, 0, ARG_DOUBLE,
                check_ambiguity, override, 0, 0,
                "lineWidth", '-',
                additional_error))
              goto failure;
          
          }
          /* height of line to detect in mm (in the world).  */
          else if (strcmp (long_options[option_index].name, "lineHeight") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->lineHeight_arg), 
                 &(args_info->lineHeight_orig), &(args_info->lineHeight_given),
                &(local_args_info.lineHeight_given), optarg, 0, 0, ARG_DOUBLE,
                check_ambiguity, override, 0, 0,
                "lineHeight", '-',
                additional_error))
              goto failure;
          
          }
          /* widht of kernel to use for filtering.  */
          else if (strcmp (long_options[option_index].name, "kernelWidth") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->kernelWidth_arg), 
                 &(args_info->kernelWidth_orig), &(args_info->kernelWidth_given),
                &(local_args_info.kernelWidth_given), optarg, 0, 0, ARG_INT,
                check_ambiguity, override, 0, 0,
                "kernelWidth", '-',
                additional_error))
              goto failure;
          
          }
          /* Height of kernel to use for filtering.  */
          else if (strcmp (long_options[option_index].name, "kernelHeight") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->kernelHeight_arg), 
                 &(args_info->kernelHeight_orig), &(args_info->kernelHeight_given),
                &(local_args_info.kernelHeight_given), optarg, 0, 0, ARG_INT,
                check_ambiguity, override, 0, 0,
                "kernelHeight", '-',
                additional_error))
              goto failure;
          
          }
          /* lower quantile to use for thresholding the filtered image.  */
          else if (strcmp (long_options[option_index].name, "lowerQuantile") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->lowerQuantile_arg), 
                 &(args_info->lowerQuantile_orig), &(args_info->lowerQuantile_given),
                &(local_args_info.lowerQuantile_given), optarg, 0, 0, ARG_DOUBLE,
                check_ambiguity, override, 0, 0,
                "lowerQuantile", '-',
                additional_error))
              goto failure;
          
          }
          /* whether to return local maxima or just the maximum.  */
          else if (strcmp (long_options[option_index].name, "localMaxima") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->localMaxima_arg), 
                 &(args_info->localMaxima_orig), &(args_info->localMaxima_given),
                &(local_args_info.localMaxima_given), optarg, 0, 0, ARG_INT,
                check_ambiguity, override, 0, 0,
                "localMaxima", '-',
                additional_error))
              goto failure;
          
          }
          /* type of grouping to use (default 0: HV lines).  */
          else if (strcmp (long_options[option_index].name, "groupingType") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->groupingType_arg), 
                 &(args_info->groupingType_orig), &(args_info->groupingType_given),
                &(local_args_info.groupingType_given), optarg, 0, 0, ARG_INT,
                check_ambiguity, override, 0, 0,
                "groupingType", '-',
                additional_error))
              goto failure;
          
          }
          /* whether to binarize the thresholded image or use the raw values.  */
          else if (strcmp (long_options[option_index].name, "binarize") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->binarize_arg), 
                 &(args_info->binarize_orig), &(args_info->binarize_given),
                &(local_args_info.binarize_given), optarg, 0, 0, ARG_DOUBLE,
                check_ambiguity, override, 0, 0,
                "binarize", '-',
                additional_error))
              goto failure;
          
          }
          /* threshold for line scores to declare as line.  */
          else if (strcmp (long_options[option_index].name, "detectionThreshold") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->detectionThreshold_arg), 
                 &(args_info->detectionThreshold_orig), &(args_info->detectionThreshold_given),
                &(local_args_info.detectionThreshold_given), optarg, 0, 0, ARG_DOUBLE,
                check_ambiguity, override, 0, 0,
                "detectionThreshold", '-',
                additional_error))
              goto failure;
          
          }
          /* whether to smooth scores of lines detected or not.  */
          else if (strcmp (long_options[option_index].name, "smoothScores") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->smoothScores_arg), 
                 &(args_info->smoothScores_orig), &(args_info->smoothScores_given),
                &(local_args_info.smoothScores_given), optarg, 0, 0, ARG_INT,
                check_ambiguity, override, 0, 0,
                "smoothScores", '-',
                additional_error))
              goto failure;
          
          }
          /* rMin for Hough transform (in pixels).  */
          else if (strcmp (long_options[option_index].name, "rMin") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->rMin_arg), 
                 &(args_info->rMin_orig), &(args_info->rMin_given),
                &(local_args_info.rMin_given), optarg, 0, 0, ARG_DOUBLE,
                check_ambiguity, override, 0, 0,
                "rMin", '-',
                additional_error))
              goto failure;
          
          }
          /* rMax for Hough transform (in pixels).  */
          else if (strcmp (long_options[option_index].name, "rMax") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->rMax_arg), 
                 &(args_info->rMax_orig), &(args_info->rMax_given),
                &(local_args_info.rMax_given), optarg, 0, 0, ARG_DOUBLE,
                check_ambiguity, override, 0, 0,
                "rMax", '-',
                additional_error))
              goto failure;
          
          }
          /* rStep for Hough transform (in pixels).  */
          else if (strcmp (long_options[option_index].name, "rStep") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->rStep_arg), 
                 &(args_info->rStep_orig), &(args_info->rStep_given),
                &(local_args_info.rStep_given), optarg, 0, 0, ARG_DOUBLE,
                check_ambiguity, override, 0, 0,
                "rStep", '-',
                additional_error))
              goto failure;
          
          }
          /* thetaMin for Hough transform (in degrees).  */
          else if (strcmp (long_options[option_index].name, "thetaMin") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->thetaMin_arg), 
                 &(args_info->thetaMin_orig), &(args_info->thetaMin_given),
                &(local_args_info.thetaMin_given), optarg, 0, 0, ARG_DOUBLE,
                check_ambiguity, override, 0, 0,
                "thetaMin", '-',
                additional_error))
              goto failure;
          
          }
          /* thetaMax for Hough transform (in degrees).  */
          else if (strcmp (long_options[option_index].name, "thetaMax") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->thetaMax_arg), 
                 &(args_info->thetaMax_orig), &(args_info->thetaMax_given),
                &(local_args_info.thetaMax_given), optarg, 0, 0, ARG_DOUBLE,
                check_ambiguity, override, 0, 0,
                "thetaMax", '-',
                additional_error))
              goto failure;
          
          }
          /* thetaStep for Hough transform (in degrees).  */
          else if (strcmp (long_options[option_index].name, "thetaStep") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->thetaStep_arg), 
                 &(args_info->thetaStep_orig), &(args_info->thetaStep_given),
                &(local_args_info.thetaStep_given), optarg, 0, 0, ARG_DOUBLE,
                check_ambiguity, override, 0, 0,
                "thetaStep", '-',
                additional_error))
              goto failure;
          
          }
          /* Portion of IPM image height to add to y-coordinate of VP.  */
          else if (strcmp (long_options[option_index].name, "ipmVpPortion") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->ipmVpPortion_arg), 
                 &(args_info->ipmVpPortion_orig), &(args_info->ipmVpPortion_given),
                &(local_args_info.ipmVpPortion_given), optarg, 0, 0, ARG_DOUBLE,
                check_ambiguity, override, 0, 0,
                "ipmVpPortion", '-',
                additional_error))
              goto failure;
          
          }
          /* Get the endpoints of the line.  */
          else if (strcmp (long_options[option_index].name, "getEndPoints") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->getEndPoints_arg), 
                 &(args_info->getEndPoints_orig), &(args_info->getEndPoints_given),
                &(local_args_info.getEndPoints_given), optarg, 0, 0, ARG_INT,
                check_ambiguity, override, 0, 0,
                "getEndPoints", '-',
                additional_error))
              goto failure;
          
          }
          /* group nearby lines or not (default 1: group).  */
          else if (strcmp (long_options[option_index].name, "group") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->group_arg), 
                 &(args_info->group_orig), &(args_info->group_given),
                &(local_args_info.group_given), optarg, 0, 0, ARG_INT,
                check_ambiguity, override, 0, 0,
                "group", '-',
                additional_error))
              goto failure;
          
          }
          /* Threshold for grouping nearby lines (default 10).  */
          else if (strcmp (long_options[option_index].name, "groupThreshold") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->groupThreshold_arg), 
                 &(args_info->groupThreshold_orig), &(args_info->groupThreshold_given),
                &(local_args_info.groupThreshold_given), optarg, 0, 0, ARG_DOUBLE,
                check_ambiguity, override, 0, 0,
                "groupThreshold", '-',
                additional_error))
              goto failure;
          
          }
          /* use RANSAC (1) or not (0).  */
          else if (strcmp (long_options[option_index].name, "ransac") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->ransac_arg), 
                 &(args_info->ransac_orig), &(args_info->ransac_given),
                &(local_args_info.ransac_given), optarg, 0, 0, ARG_INT,
                check_ambiguity, override, 0, 0,
                "ransac", '-',
                additional_error))
              goto failure;
          
          }
          /* Number of samples to use for RANSAC.  */
          else if (strcmp (long_options[option_index].name, "ransacLineNumSamples") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->ransacLineNumSamples_arg), 
                 &(args_info->ransacLineNumSamples_orig), &(args_info->ransacLineNumSamples_given),
                &(local_args_info.ransacLineNumSamples_given), optarg, 0, 0, ARG_INT,
                check_ambiguity, override, 0, 0,
                "ransacLineNumSamples", '-',
                additional_error))
              goto failure;
          
          }
          /* Number of iterations to use for RANSAC.  */
          else if (strcmp (long_options[option_index].name, "ransacLineNumIterations") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->ransacLineNumIterations_arg), 
                 &(args_info->ransacLineNumIterations_orig), &(args_info->ransacLineNumIterations_given),
                &(local_args_info.ransacLineNumIterations_given), optarg, 0, 0, ARG_INT,
                check_ambiguity, override, 0, 0,
                "ransacLineNumIterations", '-',
                additional_error))
              goto failure;
          
          }
          /* Number of close points to consider a good line fit.  */
          else if (strcmp (long_options[option_index].name, "ransacLineNumGoodFit") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->ransacLineNumGoodFit_arg), 
                 &(args_info->ransacLineNumGoodFit_orig), &(args_info->ransacLineNumGoodFit_given),
                &(local_args_info.ransacLineNumGoodFit_given), optarg, 0, 0, ARG_INT,
                check_ambiguity, override, 0, 0,
                "ransacLineNumGoodFit", '-',
                additional_error))
              goto failure;
          
          }
          /* Threshold to consider a point close.  */
          else if (strcmp (long_options[option_index].name, "ransacLineThreshold") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->ransacLineThreshold_arg), 
                 &(args_info->ransacLineThreshold_orig), &(args_info->ransacLineThreshold_given),
                &(local_args_info.ransacLineThreshold_given), optarg, 0, 0, ARG_DOUBLE,
                check_ambiguity, override, 0, 0,
                "ransacLineThreshold", '-',
                additional_error))
              goto failure;
          
          }
          /* Threshold for detected line scores.  */
          else if (strcmp (long_options[option_index].name, "ransacLineScoreThreshold") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->ransacLineScoreThreshold_arg), 
                 &(args_info->ransacLineScoreThreshold_orig), &(args_info->ransacLineScoreThreshold_given),
                &(local_args_info.ransacLineScoreThreshold_given), optarg, 0, 0, ARG_DOUBLE,
                check_ambiguity, override, 0, 0,
                "ransacLineScoreThreshold", '-',
                additional_error))
              goto failure;
          
          }
          /* Whether to binarize image for RANSAC or not.  */
          else if (strcmp (long_options[option_index].name, "ransacLineBinarize") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->ransacLineBinarize_arg), 
                 &(args_info->ransacLineBinarize_orig), &(args_info->ransacLineBinarize_given),
                &(local_args_info.ransacLineBinarize_given), optarg, 0, 0, ARG_INT,
                check_ambiguity, override, 0, 0,
                "ransacLineBinarize", '-',
                additional_error))
              goto failure;
          
          }
          /* Half width to use for ransac window.  */
          else if (strcmp (long_options[option_index].name, "ransacLineWindow") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->ransacLineWindow_arg), 
                 &(args_info->ransacLineWindow_orig), &(args_info->ransacLineWindow_given),
                &(local_args_info.ransacLineWindow_given), optarg, 0, 0, ARG_INT,
                check_ambiguity, override, 0, 0,
                "ransacLineWindow", '-',
                additional_error))
              goto failure;
          
          }
          /* Number of samples to use for RANSAC.  */
          else if (strcmp (long_options[option_index].name, "ransacSplineNumSamples") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->ransacSplineNumSamples_arg), 
                 &(args_info->ransacSplineNumSamples_orig), &(args_info->ransacSplineNumSamples_given),
                &(local_args_info.ransacSplineNumSamples_given), optarg, 0, 0, ARG_INT,
                check_ambiguity, override, 0, 0,
                "ransacSplineNumSamples", '-',
                additional_error))
              goto failure;
          
          }
          /* Number of iterations to use for RANSAC.  */
          else if (strcmp (long_options[option_index].name, "ransacSplineNumIterations") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->ransacSplineNumIterations_arg), 
                 &(args_info->ransacSplineNumIterations_orig), &(args_info->ransacSplineNumIterations_given),
                &(local_args_info.ransacSplineNumIterations_given), optarg, 0, 0, ARG_INT,
                check_ambiguity, override, 0, 0,
                "ransacSplineNumIterations", '-',
                additional_error))
              goto failure;
          
          }
          /* Number of close points to consider a good line fit.  */
          else if (strcmp (long_options[option_index].name, "ransacSplineNumGoodFit") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->ransacSplineNumGoodFit_arg), 
                 &(args_info->ransacSplineNumGoodFit_orig), &(args_info->ransacSplineNumGoodFit_given),
                &(local_args_info.ransacSplineNumGoodFit_given), optarg, 0, 0, ARG_INT,
                check_ambiguity, override, 0, 0,
                "ransacSplineNumGoodFit", '-',
                additional_error))
              goto failure;
          
          }
          /* Threshold to consider a point close.  */
          else if (strcmp (long_options[option_index].name, "ransacSplineThreshold") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->ransacSplineThreshold_arg), 
                 &(args_info->ransacSplineThreshold_orig), &(args_info->ransacSplineThreshold_given),
                &(local_args_info.ransacSplineThreshold_given), optarg, 0, 0, ARG_DOUBLE,
                check_ambiguity, override, 0, 0,
                "ransacSplineThreshold", '-',
                additional_error))
              goto failure;
          
          }
          /* Threshold for detected line scores.  */
          else if (strcmp (long_options[option_index].name, "ransacSplineScoreThreshold") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->ransacSplineScoreThreshold_arg), 
                 &(args_info->ransacSplineScoreThreshold_orig), &(args_info->ransacSplineScoreThreshold_given),
                &(local_args_info.ransacSplineScoreThreshold_given), optarg, 0, 0, ARG_DOUBLE,
                check_ambiguity, override, 0, 0,
                "ransacSplineScoreThreshold", '-',
                additional_error))
              goto failure;
          
          }
          /* Whether to binarize image for RANSAC or not.  */
          else if (strcmp (long_options[option_index].name, "ransacSplineBinarize") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->ransacSplineBinarize_arg), 
                 &(args_info->ransacSplineBinarize_orig), &(args_info->ransacSplineBinarize_given),
                &(local_args_info.ransacSplineBinarize_given), optarg, 0, 0, ARG_INT,
                check_ambiguity, override, 0, 0,
                "ransacSplineBinarize", '-',
                additional_error))
              goto failure;
          
          }
          /* Half width to use for ransac window.  */
          else if (strcmp (long_options[option_index].name, "ransacSplineWindow") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->ransacSplineWindow_arg), 
                 &(args_info->ransacSplineWindow_orig), &(args_info->ransacSplineWindow_given),
                &(local_args_info.ransacSplineWindow_given), optarg, 0, 0, ARG_INT,
                check_ambiguity, override, 0, 0,
                "ransacSplineWindow", '-',
                additional_error))
              goto failure;
          
          }
          /* Degree of spline to use.  */
          else if (strcmp (long_options[option_index].name, "ransacSplineDegree") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->ransacSplineDegree_arg), 
                 &(args_info->ransacSplineDegree_orig), &(args_info->ransacSplineDegree_given),
                &(local_args_info.ransacSplineDegree_given), optarg, 0, 0, ARG_INT,
                check_ambiguity, override, 0, 0,
                "ransacSplineDegree", '-',
                additional_error))
              goto failure;
          
          }
          /* Whether to use splines.  */
          else if (strcmp (long_options[option_index].name, "ransacSpline") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->ransacSpline_arg), 
                 &(args_info->ransacSpline_orig), &(args_info->ransacSpline_given),
                &(local_args_info.ransacSpline_given), optarg, 0, 0, ARG_INT,
                check_ambiguity, override, 0, 0,
                "ransacSpline", '-',
                additional_error))
              goto failure;
          
          }
          /* Whether to use lines.  */
          else if (strcmp (long_options[option_index].name, "ransacLine") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->ransacLine_arg), 
                 &(args_info->ransacLine_orig), &(args_info->ransacLine_given),
                &(local_args_info.ransacLine_given), optarg, 0, 0, ARG_INT,
                check_ambiguity, override, 0, 0,
                "ransacLine", '-',
                additional_error))
              goto failure;
          
          }
          /* Step to use when pixelzing spline in ransac.  */
          else if (strcmp (long_options[option_index].name, "ransacSplineStep") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->ransacSplineStep_arg), 
                 &(args_info->ransacSplineStep_orig), &(args_info->ransacSplineStep_given),
                &(local_args_info.ransacSplineStep_given), optarg, 0, 0, ARG_FLOAT,
                check_ambiguity, override, 0, 0,
                "ransacSplineStep", '-',
                additional_error))
              goto failure;
          
          }
          /* Overlap threshold to use for grouping of bounding boxes.  */
          else if (strcmp (long_options[option_index].name, "overlapThreshold") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->overlapThreshold_arg), 
                 &(args_info->overlapThreshold_orig), &(args_info->overlapThreshold_given),
                &(local_args_info.overlapThreshold_given), optarg, 0, 0, ARG_FLOAT,
                check_ambiguity, override, 0, 0,
                "overlapThreshold", '-',
                additional_error))
              goto failure;
          
          }
          /* Angle threshold used for localization (cosine, 1: most restrictive, 0: most liberal).  */
          else if (strcmp (long_options[option_index].name, "localizeAngleThreshold") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->localizeAngleThreshold_arg), 
                 &(args_info->localizeAngleThreshold_orig), &(args_info->localizeAngleThreshold_given),
                &(local_args_info.localizeAngleThreshold_given), optarg, 0, 0, ARG_FLOAT,
                check_ambiguity, override, 0, 0,
                "localizeAngleThreshold", '-',
                additional_error))
              goto failure;
          
          }
          /* Number of pixels to go in normal direction for localization.  */
          else if (strcmp (long_options[option_index].name, "localizeNumLinePixels") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->localizeNumLinePixels_arg), 
                 &(args_info->localizeNumLinePixels_orig), &(args_info->localizeNumLinePixels_given),
                &(local_args_info.localizeNumLinePixels_given), optarg, 0, 0, ARG_INT,
                check_ambiguity, override, 0, 0,
                "localizeNumLinePixels", '-',
                additional_error))
              goto failure;
          
          }
          /* Angle threshold used for extending (cosine, 1: most restrictive, 0: most liberal).  */
          else if (strcmp (long_options[option_index].name, "extendAngleThreshold") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->extendAngleThreshold_arg), 
                 &(args_info->extendAngleThreshold_orig), &(args_info->extendAngleThreshold_given),
                &(local_args_info.extendAngleThreshold_given), optarg, 0, 0, ARG_FLOAT,
                check_ambiguity, override, 0, 0,
                "extendAngleThreshold", '-',
                additional_error))
              goto failure;
          
          }
          /* Angle threshold from mean direction used for extending (cosine, 1: most restrictive, 0: most liberal).  */
          else if (strcmp (long_options[option_index].name, "extendMeanDirAngleThreshold") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->extendMeanDirAngleThreshold_arg), 
                 &(args_info->extendMeanDirAngleThreshold_orig), &(args_info->extendMeanDirAngleThreshold_given),
                &(local_args_info.extendMeanDirAngleThreshold_given), optarg, 0, 0, ARG_FLOAT,
                check_ambiguity, override, 0, 0,
                "extendMeanDirAngleThreshold", '-',
                additional_error))
              goto failure;
          
          }
          /* Angle threshold from mean direction used for extending back (cosine, 1: most restrictive, 0: most liberal).  */
          else if (strcmp (long_options[option_index].name, "extendMeanDirAngleThresholdBack") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->extendMeanDirAngleThresholdBack_arg), 
                 &(args_info->extendMeanDirAngleThresholdBack_orig), &(args_info->extendMeanDirAngleThresholdBack_given),
                &(local_args_info.extendMeanDirAngleThresholdBack_given), optarg, 0, 0, ARG_FLOAT,
                check_ambiguity, override, 0, 0,
                "extendMeanDirAngleThresholdBack", '-',
                additional_error))
              goto failure;
          
          }
          /* Angle threshold from mean direction used for extending forward (cosine, 1: most restrictive, 0: most liberal).  */
          else if (strcmp (long_options[option_index].name, "extendMeanDirAngleThresholdForward") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->extendMeanDirAngleThresholdForward_arg), 
                 &(args_info->extendMeanDirAngleThresholdForward_orig), &(args_info->extendMeanDirAngleThresholdForward_given),
                &(local_args_info.extendMeanDirAngleThresholdForward_given), optarg, 0, 0, ARG_FLOAT,
                check_ambiguity, override, 0, 0,
                "extendMeanDirAngleThresholdForward", '-',
                additional_error))
              goto failure;
          
          }
          /* Number of pixels to go in tangent direction for extending.  */
          else if (strcmp (long_options[option_index].name, "extendLinePixelsTangent") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->extendLinePixelsTangent_arg), 
                 &(args_info->extendLinePixelsTangent_orig), &(args_info->extendLinePixelsTangent_given),
                &(local_args_info.extendLinePixelsTangent_given), optarg, 0, 0, ARG_INT,
                check_ambiguity, override, 0, 0,
                "extendLinePixelsTangent", '-',
                additional_error))
              goto failure;
          
          }
          /* Number of pixels to go in tangent direction for extending.  */
          else if (strcmp (long_options[option_index].name, "extendLinePixelsNormal") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->extendLinePixelsNormal_arg), 
                 &(args_info->extendLinePixelsNormal_orig), &(args_info->extendLinePixelsNormal_given),
                &(local_args_info.extendLinePixelsNormal_given), optarg, 0, 0, ARG_INT,
                check_ambiguity, override, 0, 0,
                "extendLinePixelsNormal", '-',
                additional_error))
              goto failure;
          
          }
          /* Threhsold used for stopping the extending process (higher -> less extending).  */
          else if (strcmp (long_options[option_index].name, "extendContThreshold") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->extendContThreshold_arg), 
                 &(args_info->extendContThreshold_orig), &(args_info->extendContThreshold_given),
                &(local_args_info.extendContThreshold_given), optarg, 0, 0, ARG_FLOAT,
                check_ambiguity, override, 0, 0,
                "extendContThreshold", '-',
                additional_error))
              goto failure;
          
          }
          /* Stop extending when number of deviating points exceeds this threshold.  */
          else if (strcmp (long_options[option_index].name, "extendDeviationThreshold") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->extendDeviationThreshold_arg), 
                 &(args_info->extendDeviationThreshold_orig), &(args_info->extendDeviationThreshold_given),
                &(local_args_info.extendDeviationThreshold_given), optarg, 0, 0, ARG_INT,
                check_ambiguity, override, 0, 0,
                "extendDeviationThreshold", '-',
                additional_error))
              goto failure;
          
          }
          /* Top point for extension bounding box.  */
          else if (strcmp (long_options[option_index].name, "extendRectTop") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->extendRectTop_arg), 
                 &(args_info->extendRectTop_orig), &(args_info->extendRectTop_given),
                &(local_args_info.extendRectTop_given), optarg, 0, 0, ARG_INT,
                check_ambiguity, override, 0, 0,
                "extendRectTop", '-',
                additional_error))
              goto failure;
          
          }
          /* Bottom point for extension bounding box.  */
          else if (strcmp (long_options[option_index].name, "extendRectBottom") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->extendRectBottom_arg), 
                 &(args_info->extendRectBottom_orig), &(args_info->extendRectBottom_given),
                &(local_args_info.extendRectBottom_given), optarg, 0, 0, ARG_INT,
                check_ambiguity, override, 0, 0,
                "extendRectBottom", '-',
                additional_error))
              goto failure;
          
          }
          /* Angle threshold used for extending (cosine, 1: most restrictive, 0: most liberal).  */
          else if (strcmp (long_options[option_index].name, "extendIPMAngleThreshold") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->extendIPMAngleThreshold_arg), 
                 &(args_info->extendIPMAngleThreshold_orig), &(args_info->extendIPMAngleThreshold_given),
                &(local_args_info.extendIPMAngleThreshold_given), optarg, 0, 0, ARG_FLOAT,
                check_ambiguity, override, 0, 0,
                "extendIPMAngleThreshold", '-',
                additional_error))
              goto failure;
          
          }
          /* Angle threshold from mean direction used for extending (cosine, 1: most restrictive, 0: most liberal).  */
          else if (strcmp (long_options[option_index].name, "extendIPMMeanDirAngleThreshold") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->extendIPMMeanDirAngleThreshold_arg), 
                 &(args_info->extendIPMMeanDirAngleThreshold_orig), &(args_info->extendIPMMeanDirAngleThreshold_given),
                &(local_args_info.extendIPMMeanDirAngleThreshold_given), optarg, 0, 0, ARG_FLOAT,
                check_ambiguity, override, 0, 0,
                "extendIPMMeanDirAngleThreshold", '-',
                additional_error))
              goto failure;
          
          }
          /* Number of pixels to go in tangent direction for extending.  */
          else if (strcmp (long_options[option_index].name, "extendIPMLinePixelsTangent") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->extendIPMLinePixelsTangent_arg), 
                 &(args_info->extendIPMLinePixelsTangent_orig), &(args_info->extendIPMLinePixelsTangent_given),
                &(local_args_info.extendIPMLinePixelsTangent_given), optarg, 0, 0, ARG_INT,
                check_ambiguity, override, 0, 0,
                "extendIPMLinePixelsTangent", '-',
                additional_error))
              goto failure;
          
          }
          /* Number of pixels to go in tangent direction for extending.  */
          else if (strcmp (long_options[option_index].name, "extendIPMLinePixelsNormal") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->extendIPMLinePixelsNormal_arg), 
                 &(args_info->extendIPMLinePixelsNormal_orig), &(args_info->extendIPMLinePixelsNormal_given),
                &(local_args_info.extendIPMLinePixelsNormal_given), optarg, 0, 0, ARG_INT,
                check_ambiguity, override, 0, 0,
                "extendIPMLinePixelsNormal", '-',
                additional_error))
              goto failure;
          
          }
          /* Threhsold used for stopping the extending process (higher -> less extending).  */
          else if (strcmp (long_options[option_index].name, "extendIPMContThreshold") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->extendIPMContThreshold_arg), 
                 &(args_info->extendIPMContThreshold_orig), &(args_info->extendIPMContThreshold_given),
                &(local_args_info.extendIPMContThreshold_given), optarg, 0, 0, ARG_FLOAT,
                check_ambiguity, override, 0, 0,
                "extendIPMContThreshold", '-',
                additional_error))
              goto failure;
          
          }
          /* Stop extending when number of deviating points exceeds this threshold.  */
          else if (strcmp (long_options[option_index].name, "extendIPMDeviationThreshold") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->extendIPMDeviationThreshold_arg), 
                 &(args_info->extendIPMDeviationThreshold_orig), &(args_info->extendIPMDeviationThreshold_given),
                &(local_args_info.extendIPMDeviationThreshold_given), optarg, 0, 0, ARG_INT,
                check_ambiguity, override, 0, 0,
                "extendIPMDeviationThreshold", '-',
                additional_error))
              goto failure;
          
          }
          /* Top point for extension bounding box.  */
          else if (strcmp (long_options[option_index].name, "extendIPMRectTop") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->extendIPMRectTop_arg), 
                 &(args_info->extendIPMRectTop_orig), &(args_info->extendIPMRectTop_given),
                &(local_args_info.extendIPMRectTop_given), optarg, 0, 0, ARG_INT,
                check_ambiguity, override, 0, 0,
                "extendIPMRectTop", '-',
                additional_error))
              goto failure;
          
          }
          /* Bottom point for extension bounding box.  */
          else if (strcmp (long_options[option_index].name, "extendIPMRectBottom") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->extendIPMRectBottom_arg), 
                 &(args_info->extendIPMRectBottom_orig), &(args_info->extendIPMRectBottom_given),
                &(local_args_info.extendIPMRectBottom_given), optarg, 0, 0, ARG_INT,
                check_ambiguity, override, 0, 0,
                "extendIPMRectBottom", '-',
                additional_error))
              goto failure;
          
          }
          /* Number of pixels to go around the spline to compute score.  */
          else if (strcmp (long_options[option_index].name, "splineScoreJitter") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->splineScoreJitter_arg), 
                 &(args_info->splineScoreJitter_orig), &(args_info->splineScoreJitter_given),
                &(local_args_info.splineScoreJitter_given), optarg, 0, 0, ARG_INT,
                check_ambiguity, override, 0, 0,
                "splineScoreJitter", '-',
                additional_error))
              goto failure;
          
          }
          /* Ratio of spline length to use.  */
          else if (strcmp (long_options[option_index].name, "splineScoreLengthRatio") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->splineScoreLengthRatio_arg), 
                 &(args_info->splineScoreLengthRatio_orig), &(args_info->splineScoreLengthRatio_given),
                &(local_args_info.splineScoreLengthRatio_given), optarg, 0, 0, ARG_FLOAT,
                check_ambiguity, override, 0, 0,
                "splineScoreLengthRatio", '-',
                additional_error))
              goto failure;
          
          }
          /* Ratio of spline angle to use.  */
          else if (strcmp (long_options[option_index].name, "splineScoreAngleRatio") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->splineScoreAngleRatio_arg), 
                 &(args_info->splineScoreAngleRatio_orig), &(args_info->splineScoreAngleRatio_given),
                &(local_args_info.splineScoreAngleRatio_given), optarg, 0, 0, ARG_FLOAT,
                check_ambiguity, override, 0, 0,
                "splineScoreAngleRatio", '-',
                additional_error))
              goto failure;
          
          }
          /* Step to use for spline score computation.  */
          else if (strcmp (long_options[option_index].name, "splineScoreStep") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->splineScoreStep_arg), 
                 &(args_info->splineScoreStep_orig), &(args_info->splineScoreStep_given),
                &(local_args_info.splineScoreStep_given), optarg, 0, 0, ARG_FLOAT,
                check_ambiguity, override, 0, 0,
                "splineScoreStep", '-',
                additional_error))
              goto failure;
          
          }
          /* number of frames the track is allowed to be absent before deleting it.  */
          else if (strcmp (long_options[option_index].name, "splineTrackingNumAbsentFrames") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->splineTrackingNumAbsentFrames_arg), 
                 &(args_info->splineTrackingNumAbsentFrames_orig), &(args_info->splineTrackingNumAbsentFrames_given),
                &(local_args_info.splineTrackingNumAbsentFrames_given), optarg, 0, 0, ARG_INT,
                check_ambiguity, override, 0, 0,
                "splineTrackingNumAbsentFrames", '-',
                additional_error))
              goto failure;
          
          }
          /* number of frames before considering the track good.  */
          else if (strcmp (long_options[option_index].name, "splineTrackingNumSeenFrames") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->splineTrackingNumSeenFrames_arg), 
                 &(args_info->splineTrackingNumSeenFrames_orig), &(args_info->splineTrackingNumSeenFrames_given),
                &(local_args_info.splineTrackingNumSeenFrames_given), optarg, 0, 0, ARG_INT,
                check_ambiguity, override, 0, 0,
                "splineTrackingNumSeenFrames", '-',
                additional_error))
              goto failure;
          
          }
          /* Angle threshold for merging splines (radians).  */
          else if (strcmp (long_options[option_index].name, "mergeSplineThetaThreshold") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->mergeSplineThetaThreshold_arg), 
                 &(args_info->mergeSplineThetaThreshold_orig), &(args_info->mergeSplineThetaThreshold_given),
                &(local_args_info.mergeSplineThetaThreshold_given), optarg, 0, 0, ARG_FLOAT,
                check_ambiguity, override, 0, 0,
                "mergeSplineThetaThreshold", '-',
                additional_error))
              goto failure;
          
          }
          /* R threshold (distance from origin) for merginn splines.  */
          else if (strcmp (long_options[option_index].name, "mergeSplineRThreshold") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->mergeSplineRThreshold_arg), 
                 &(args_info->mergeSplineRThreshold_orig), &(args_info->mergeSplineRThreshold_given),
                &(local_args_info.mergeSplineRThreshold_given), optarg, 0, 0, ARG_FLOAT,
                check_ambiguity, override, 0, 0,
                "mergeSplineRThreshold", '-',
                additional_error))
              goto failure;
          
          }
          /* Mean Angle threshold for merging splines (radians).  */
          else if (strcmp (long_options[option_index].name, "mergeSplineMeanThetaThreshold") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->mergeSplineMeanThetaThreshold_arg), 
                 &(args_info->mergeSplineMeanThetaThreshold_orig), &(args_info->mergeSplineMeanThetaThreshold_given),
                &(local_args_info.mergeSplineMeanThetaThreshold_given), optarg, 0, 0, ARG_FLOAT,
                check_ambiguity, override, 0, 0,
                "mergeSplineMeanThetaThreshold", '-',
                additional_error))
              goto failure;
          
          }
          /* Mean R threshold (distance from origin) for merginn splines.  */
          else if (strcmp (long_options[option_index].name, "mergeSplineMeanRThreshold") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->mergeSplineMeanRThreshold_arg), 
                 &(args_info->mergeSplineMeanRThreshold_orig), &(args_info->mergeSplineMeanRThreshold_given),
                &(local_args_info.mergeSplineMeanRThreshold_given), optarg, 0, 0, ARG_FLOAT,
                check_ambiguity, override, 0, 0,
                "mergeSplineMeanRThreshold", '-',
                additional_error))
              goto failure;
          
          }
          /* Distance threshold between spline cetroids for merging.  */
          else if (strcmp (long_options[option_index].name, "mergeSplineCentroidThreshold") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->mergeSplineCentroidThreshold_arg), 
                 &(args_info->mergeSplineCentroidThreshold_orig), &(args_info->mergeSplineCentroidThreshold_given),
                &(local_args_info.mergeSplineCentroidThreshold_given), optarg, 0, 0, ARG_FLOAT,
                check_ambiguity, override, 0, 0,
                "mergeSplineCentroidThreshold", '-',
                additional_error))
              goto failure;
          
          }
          /* number of frames the track is allowed to be absent before deleting it.  */
          else if (strcmp (long_options[option_index].name, "lineTrackingNumAbsentFrames") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->lineTrackingNumAbsentFrames_arg), 
                 &(args_info->lineTrackingNumAbsentFrames_orig), &(args_info->lineTrackingNumAbsentFrames_given),
                &(local_args_info.lineTrackingNumAbsentFrames_given), optarg, 0, 0, ARG_INT,
                check_ambiguity, override, 0, 0,
                "lineTrackingNumAbsentFrames", '-',
                additional_error))
              goto failure;
          
          }
          /* number of frames before considering the track good.  */
          else if (strcmp (long_options[option_index].name, "lineTrackingNumSeenFrames") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->lineTrackingNumSeenFrames_arg), 
                 &(args_info->lineTrackingNumSeenFrames_orig), &(args_info->lineTrackingNumSeenFrames_given),
                &(local_args_info.lineTrackingNumSeenFrames_given), optarg, 0, 0, ARG_INT,
                check_ambiguity, override, 0, 0,
                "lineTrackingNumSeenFrames", '-',
                additional_error))
              goto failure;
          
          }
          /* Angle threshold for merging lines (radians).  */
          else if (strcmp (long_options[option_index].name, "mergeLineThetaThreshold") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->mergeLineThetaThreshold_arg), 
                 &(args_info->mergeLineThetaThreshold_orig), &(args_info->mergeLineThetaThreshold_given),
                &(local_args_info.mergeLineThetaThreshold_given), optarg, 0, 0, ARG_FLOAT,
                check_ambiguity, override, 0, 0,
                "mergeLineThetaThreshold", '-',
                additional_error))
              goto failure;
          
          }
          /* R threshold (distance from origin) for merging lines.  */
          else if (strcmp (long_options[option_index].name, "mergeLineRThreshold") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->mergeLineRThreshold_arg), 
                 &(args_info->mergeLineRThreshold_orig), &(args_info->mergeLineRThreshold_given),
                &(local_args_info.mergeLineRThreshold_given), optarg, 0, 0, ARG_FLOAT,
                check_ambiguity, override, 0, 0,
                "mergeLineRThreshold", '-',
                additional_error))
              goto failure;
          
          }
          /* Number of horizontal strips to divide the image to.  */
          else if (strcmp (long_options[option_index].name, "numStrips") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->numStrips_arg), 
                 &(args_info->numStrips_orig), &(args_info->numStrips_given),
                &(local_args_info.numStrips_given), optarg, 0, 0, ARG_INT,
                check_ambiguity, override, 0, 0,
                "numStrips", '-',
                additional_error))
              goto failure;
          
          }
          /* Whtethet to check splines or not.  */
          else if (strcmp (long_options[option_index].name, "checkSplines") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->checkSplines_arg), 
                 &(args_info->checkSplines_orig), &(args_info->checkSplines_given),
                &(local_args_info.checkSplines_given), optarg, 0, 0, ARG_INT,
                check_ambiguity, override, 0, 0,
                "checkSplines", '-',
                additional_error))
              goto failure;
          
          }
          /* Curveness Threshold for checking splines.  */
          else if (strcmp (long_options[option_index].name, "checkSplinesCurvenessThreshold") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->checkSplinesCurvenessThreshold_arg), 
                 &(args_info->checkSplinesCurvenessThreshold_orig), &(args_info->checkSplinesCurvenessThreshold_given),
                &(local_args_info.checkSplinesCurvenessThreshold_given), optarg, 0, 0, ARG_FLOAT,
                check_ambiguity, override, 0, 0,
                "checkSplinesCurvenessThreshold", '-',
                additional_error))
              goto failure;
          
          }
          /* Length Threshold for checking splines.  */
          else if (strcmp (long_options[option_index].name, "checkSplinesLengthThreshold") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->checkSplinesLengthThreshold_arg), 
                 &(args_info->checkSplinesLengthThreshold_orig), &(args_info->checkSplinesLengthThreshold_given),
                &(local_args_info.checkSplinesLengthThreshold_given), optarg, 0, 0, ARG_FLOAT,
                check_ambiguity, override, 0, 0,
                "checkSplinesLengthThreshold", '-',
                additional_error))
              goto failure;
          
          }
          /* ThetaDiff Threshold for checking splines.  */
          else if (strcmp (long_options[option_index].name, "checkSplinesThetaDiffThreshold") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->checkSplinesThetaDiffThreshold_arg), 
                 &(args_info->checkSplinesThetaDiffThreshold_orig), &(args_info->checkSplinesThetaDiffThreshold_given),
                &(local_args_info.checkSplinesThetaDiffThreshold_given), optarg, 0, 0, ARG_FLOAT,
                check_ambiguity, override, 0, 0,
                "checkSplinesThetaDiffThreshold", '-',
                additional_error))
              goto failure;
          
          }
          /* ThetaThreshold Threshold for checking splines.  */
          else if (strcmp (long_options[option_index].name, "checkSplinesThetaThreshold") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->checkSplinesThetaThreshold_arg), 
                 &(args_info->checkSplinesThetaThreshold_orig), &(args_info->checkSplinesThetaThreshold_given),
                &(local_args_info.checkSplinesThetaThreshold_given), optarg, 0, 0, ARG_FLOAT,
                check_ambiguity, override, 0, 0,
                "checkSplinesThetaThreshold", '-',
                additional_error))
              goto failure;
          
          }
          /* Whtethet to check IPM splines or not.  */
          else if (strcmp (long_options[option_index].name, "checkIPMSplines") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->checkIPMSplines_arg), 
                 &(args_info->checkIPMSplines_orig), &(args_info->checkIPMSplines_given),
                &(local_args_info.checkIPMSplines_given), optarg, 0, 0, ARG_INT,
                check_ambiguity, override, 0, 0,
                "checkIPMSplines", '-',
                additional_error))
              goto failure;
          
          }
          /* Curveness Threshold for checking splines.  */
          else if (strcmp (long_options[option_index].name, "checkIPMSplinesCurvenessThreshold") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->checkIPMSplinesCurvenessThreshold_arg), 
                 &(args_info->checkIPMSplinesCurvenessThreshold_orig), &(args_info->checkIPMSplinesCurvenessThreshold_given),
                &(local_args_info.checkIPMSplinesCurvenessThreshold_given), optarg, 0, 0, ARG_FLOAT,
                check_ambiguity, override, 0, 0,
                "checkIPMSplinesCurvenessThreshold", '-',
                additional_error))
              goto failure;
          
          }
          /* Length Threshold for checking splines.  */
          else if (strcmp (long_options[option_index].name, "checkIPMSplinesLengthThreshold") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->checkIPMSplinesLengthThreshold_arg), 
                 &(args_info->checkIPMSplinesLengthThreshold_orig), &(args_info->checkIPMSplinesLengthThreshold_given),
                &(local_args_info.checkIPMSplinesLengthThreshold_given), optarg, 0, 0, ARG_FLOAT,
                check_ambiguity, override, 0, 0,
                "checkIPMSplinesLengthThreshold", '-',
                additional_error))
              goto failure;
          
          }
          /* ThetaDiff Threshold for checking splines.  */
          else if (strcmp (long_options[option_index].name, "checkIPMSplinesThetaDiffThreshold") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->checkIPMSplinesThetaDiffThreshold_arg), 
                 &(args_info->checkIPMSplinesThetaDiffThreshold_orig), &(args_info->checkIPMSplinesThetaDiffThreshold_given),
                &(local_args_info.checkIPMSplinesThetaDiffThreshold_given), optarg, 0, 0, ARG_FLOAT,
                check_ambiguity, override, 0, 0,
                "checkIPMSplinesThetaDiffThreshold", '-',
                additional_error))
              goto failure;
          
          }
          /* ThetaThreshold Threshold for checking splines.  */
          else if (strcmp (long_options[option_index].name, "checkIPMSplinesThetaThreshold") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->checkIPMSplinesThetaThreshold_arg), 
                 &(args_info->checkIPMSplinesThetaThreshold_orig), &(args_info->checkIPMSplinesThetaThreshold_given),
                &(local_args_info.checkIPMSplinesThetaThreshold_given), optarg, 0, 0, ARG_FLOAT,
                check_ambiguity, override, 0, 0,
                "checkIPMSplinesThetaThreshold", '-',
                additional_error))
              goto failure;
          
          }
          /* Final Threshold for declaring a valid spline.  */
          else if (strcmp (long_options[option_index].name, "finalSplineScoreThreshold") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->finalSplineScoreThreshold_arg), 
                 &(args_info->finalSplineScoreThreshold_orig), &(args_info->finalSplineScoreThreshold_given),
                &(local_args_info.finalSplineScoreThreshold_given), optarg, 0, 0, ARG_FLOAT,
                check_ambiguity, override, 0, 0,
                "finalSplineScoreThreshold", '-',
                additional_error))
              goto failure;
          
          }
          /* Use groudn plane or not when sending to map.  */
          else if (strcmp (long_options[option_index].name, "useGroundPlane") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->useGroundPlane_arg), 
                 &(args_info->useGroundPlane_orig), &(args_info->useGroundPlane_given),
                &(local_args_info.useGroundPlane_given), optarg, 0, 0, ARG_INT,
                check_ambiguity, override, 0, 0,
                "useGroundPlane", '-',
                additional_error))
              goto failure;
          
          }
          /* Whether to check colors or not.  */
          else if (strcmp (long_options[option_index].name, "checkColor") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->checkColor_arg), 
                 &(args_info->checkColor_orig), &(args_info->checkColor_given),
                &(local_args_info.checkColor_given), optarg, 0, 0, ARG_INT,
                check_ambiguity, override, 0, 0,
                "checkColor", '-',
                additional_error))
              goto failure;
          
          }
          /* Size of window to use.  */
          else if (strcmp (long_options[option_index].name, "checkColorWindow") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->checkColorWindow_arg), 
                 &(args_info->checkColorWindow_orig), &(args_info->checkColorWindow_given),
                &(local_args_info.checkColorWindow_given), optarg, 0, 0, ARG_INT,
                check_ambiguity, override, 0, 0,
                "checkColorWindow", '-',
                additional_error))
              goto failure;
          
          }
          /* Number of bins to use.  */
          else if (strcmp (long_options[option_index].name, "checkColorNumBins") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->checkColorNumBins_arg), 
                 &(args_info->checkColorNumBins_orig), &(args_info->checkColorNumBins_given),
                &(local_args_info.checkColorNumBins_given), optarg, 0, 0, ARG_INT,
                check_ambiguity, override, 0, 0,
                "checkColorNumBins", '-',
                additional_error))
              goto failure;
          
          }
          /* Min ratio of yellow points.  */
          else if (strcmp (long_options[option_index].name, "checkColorNumYellowMin") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->checkColorNumYellowMin_arg), 
                 &(args_info->checkColorNumYellowMin_orig), &(args_info->checkColorNumYellowMin_given),
                &(local_args_info.checkColorNumYellowMin_given), optarg, 0, 0, ARG_FLOAT,
                check_ambiguity, override, 0, 0,
                "checkColorNumYellowMin", '-',
                additional_error))
              goto failure;
          
          }
          /* Min RG diff.  */
          else if (strcmp (long_options[option_index].name, "checkColorRGMin") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->checkColorRGMin_arg), 
                 &(args_info->checkColorRGMin_orig), &(args_info->checkColorRGMin_given),
                &(local_args_info.checkColorRGMin_given), optarg, 0, 0, ARG_FLOAT,
                check_ambiguity, override, 0, 0,
                "checkColorRGMin", '-',
                additional_error))
              goto failure;
          
          }
          /* Max RG diff.  */
          else if (strcmp (long_options[option_index].name, "checkColorRGMax") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->checkColorRGMax_arg), 
                 &(args_info->checkColorRGMax_orig), &(args_info->checkColorRGMax_given),
                &(local_args_info.checkColorRGMax_given), optarg, 0, 0, ARG_FLOAT,
                check_ambiguity, override, 0, 0,
                "checkColorRGMax", '-',
                additional_error))
              goto failure;
          
          }
          /* Min GB diff.  */
          else if (strcmp (long_options[option_index].name, "checkColorGBMin") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->checkColorGBMin_arg), 
                 &(args_info->checkColorGBMin_orig), &(args_info->checkColorGBMin_given),
                &(local_args_info.checkColorGBMin_given), optarg, 0, 0, ARG_FLOAT,
                check_ambiguity, override, 0, 0,
                "checkColorGBMin", '-',
                additional_error))
              goto failure;
          
          }
          /* Min RB diff.  */
          else if (strcmp (long_options[option_index].name, "checkColorRBMin") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->checkColorRBMin_arg), 
                 &(args_info->checkColorRBMin_orig), &(args_info->checkColorRBMin_given),
                &(local_args_info.checkColorRBMin_given), optarg, 0, 0, ARG_FLOAT,
                check_ambiguity, override, 0, 0,
                "checkColorRBMin", '-',
                additional_error))
              goto failure;
          
          }
          /* RBF Threshold.  */
          else if (strcmp (long_options[option_index].name, "checkColorRBFThreshold") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->checkColorRBFThreshold_arg), 
                 &(args_info->checkColorRBFThreshold_orig), &(args_info->checkColorRBFThreshold_given),
                &(local_args_info.checkColorRBFThreshold_given), optarg, 0, 0, ARG_FLOAT,
                check_ambiguity, override, 0, 0,
                "checkColorRBFThreshold", '-',
                additional_error))
              goto failure;
          
          }
          /* Whether to use RBF or not.  */
          else if (strcmp (long_options[option_index].name, "checkColorRBF") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->checkColorRBF_arg), 
                 &(args_info->checkColorRBF_orig), &(args_info->checkColorRBF_given),
                &(local_args_info.checkColorRBF_given), optarg, 0, 0, ARG_INT,
                check_ambiguity, override, 0, 0,
                "checkColorRBF", '-',
                additional_error))
              goto failure;
          
          }
          /* Whether to clear part of the IPM image.  */
          else if (strcmp (long_options[option_index].name, "ipmWindowClear") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->ipmWindowClear_arg), 
                 &(args_info->ipmWindowClear_orig), &(args_info->ipmWindowClear_given),
                &(local_args_info.ipmWindowClear_given), optarg, 0, 0, ARG_INT,
                check_ambiguity, override, 0, 0,
                "ipmWindowClear", '-',
                additional_error))
              goto failure;
          
          }
          /* Left corrdinate of window to keep in IPM.  */
          else if (strcmp (long_options[option_index].name, "ipmWindowLeft") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->ipmWindowLeft_arg), 
                 &(args_info->ipmWindowLeft_orig), &(args_info->ipmWindowLeft_given),
                &(local_args_info.ipmWindowLeft_given), optarg, 0, 0, ARG_INT,
                check_ambiguity, override, 0, 0,
                "ipmWindowLeft", '-',
                additional_error))
              goto failure;
          
          }
          /* Left corrdinate of window to keep in IPM.  */
          else if (strcmp (long_options[option_index].name, "ipmWindowRight") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->ipmWindowRight_arg), 
                 &(args_info->ipmWindowRight_orig), &(args_info->ipmWindowRight_given),
                &(local_args_info.ipmWindowRight_given), optarg, 0, 0, ARG_INT,
                check_ambiguity, override, 0, 0,
                "ipmWindowRight", '-',
                additional_error))
              goto failure;
          
          }
          /* Whether to check lane width or not.  */
          else if (strcmp (long_options[option_index].name, "checkLaneWidth") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->checkLaneWidth_arg), 
                 &(args_info->checkLaneWidth_orig), &(args_info->checkLaneWidth_given),
                &(local_args_info.checkLaneWidth_given), optarg, 0, 0, ARG_INT,
                check_ambiguity, override, 0, 0,
                "checkLaneWidth", '-',
                additional_error))
              goto failure;
          
          }
          /* Mean of lane width to look for.  */
          else if (strcmp (long_options[option_index].name, "checkLaneWidthMean") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->checkLaneWidthMean_arg), 
                 &(args_info->checkLaneWidthMean_orig), &(args_info->checkLaneWidthMean_given),
                &(local_args_info.checkLaneWidthMean_given), optarg, 0, 0, ARG_FLOAT,
                check_ambiguity, override, 0, 0,
                "checkLaneWidthMean", '-',
                additional_error))
              goto failure;
          
          }
          /* Std deviation of lane width to look for.  */
          else if (strcmp (long_options[option_index].name, "checkLaneWidthStd") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->checkLaneWidthStd_arg), 
                 &(args_info->checkLaneWidthStd_orig), &(args_info->checkLaneWidthStd_given),
                &(local_args_info.checkLaneWidthStd_given), optarg, 0, 0, ARG_FLOAT,
                check_ambiguity, override, 0, 0,
                "checkLaneWidthStd", '-',
                additional_error))
              goto failure;
          
          }
          
          break;
        case '?':	/* Invalid option.  */
          /* `getopt_long' already printed an error message.  */
          goto failure;

        default:	/* bug: option not considered.  */
          fprintf (stderr, "%s: option unknown: %c%s\n", LANEDETECTORPARSER_PACKAGE, c, (additional_error ? additional_error : ""));
          abort ();
        } /* switch */
    } /* while */



  if (check_required)
    {
      error_occurred += LaneDetectorParser_required2 (args_info, argv[0], additional_error);
    }

  LaneDetectorParser_release (&local_args_info);

  if ( error_occurred )
    return (EXIT_FAILURE);

  return 0;

failure:
  
  LaneDetectorParser_release (&local_args_info);
  return (EXIT_FAILURE);
}

#ifndef CONFIG_FILE_LINE_SIZE
#define CONFIG_FILE_LINE_SIZE 2048
#endif
#define ADDITIONAL_ERROR " in configuration file "

#define CONFIG_FILE_LINE_BUFFER_SIZE (CONFIG_FILE_LINE_SIZE+3)
/* 3 is for "--" and "=" */

static int
_LaneDetectorParser_configfile (const char *filename, int *my_argc)
{
  FILE* file;
  char my_argv[CONFIG_FILE_LINE_BUFFER_SIZE+1];
  char linebuf[CONFIG_FILE_LINE_SIZE];
  int line_num = 0;
  int result = 0, equal;
  char *fopt, *farg;
  char *str_index;
  size_t len, next_token;
  char delimiter;

  if ((file = fopen(filename, "r")) == 0)
    {
      fprintf (stderr, "%s: Error opening configuration file '%s'\n",
               LANEDETECTORPARSER_PACKAGE, filename);
      return EXIT_FAILURE;
    }

  while ((fgets(linebuf, CONFIG_FILE_LINE_SIZE, file)) != 0)
    {
      ++line_num;
      my_argv[0] = '\0';
      len = strlen(linebuf);
      if (len > (CONFIG_FILE_LINE_BUFFER_SIZE-1))
        {
          fprintf (stderr, "%s:%s:%d: Line too long in configuration file\n",
                   LANEDETECTORPARSER_PACKAGE, filename, line_num);
          result = EXIT_FAILURE;
          break;
        }

      /* find first non-whitespace character in the line */
      next_token = strspn (linebuf, " \t\r\n");
      str_index  = linebuf + next_token;

      if ( str_index[0] == '\0' || str_index[0] == '#')
        continue; /* empty line or comment line is skipped */

      fopt = str_index;

      /* truncate fopt at the end of the first non-valid character */
      next_token = strcspn (fopt, " \t\r\n=");

      if (fopt[next_token] == '\0') /* the line is over */
        {
          farg  = 0;
          equal = 0;
          goto noarg;
        }

      /* remember if equal sign is present */
      equal = (fopt[next_token] == '=');
      fopt[next_token++] = '\0';

      /* advance pointers to the next token after the end of fopt */
      next_token += strspn (fopt + next_token, " \t\r\n");

      /* check for the presence of equal sign, and if so, skip it */
      if ( !equal )
        if ((equal = (fopt[next_token] == '=')))
          {
            next_token++;
            next_token += strspn (fopt + next_token, " \t\r\n");
          }
      str_index  += next_token;

      /* find argument */
      farg = str_index;
      if ( farg[0] == '\"' || farg[0] == '\'' )
        { /* quoted argument */
          str_index = strchr (++farg, str_index[0] ); /* skip opening quote */
          if (! str_index)
            {
              fprintf
                (stderr,
                 "%s:%s:%d: unterminated string in configuration file\n",
                 LANEDETECTORPARSER_PACKAGE, filename, line_num);
              result = EXIT_FAILURE;
              break;
            }
        }
      else
        { /* read up the remaining part up to a delimiter */
          next_token = strcspn (farg, " \t\r\n#\'\"");
          str_index += next_token;
        }

      /* truncate farg at the delimiter and store it for further check */
      delimiter = *str_index, *str_index++ = '\0';

      /* everything but comment is illegal at the end of line */
      if (delimiter != '\0' && delimiter != '#')
        {
          str_index += strspn(str_index, " \t\r\n");
          if (*str_index != '\0' && *str_index != '#')
            {
              fprintf
                (stderr,
                 "%s:%s:%d: malformed string in configuration file\n",
                 LANEDETECTORPARSER_PACKAGE, filename, line_num);
              result = EXIT_FAILURE;
              break;
            }
        }

    noarg:
      if (!strcmp(fopt,"include")) {
        if (farg && *farg) {
          result = _LaneDetectorParser_configfile(farg, my_argc);
        } else {
          fprintf(stderr, "%s:%s:%d: include requires a filename argument.\n",
                  LANEDETECTORPARSER_PACKAGE, filename, line_num);
        }
        continue;
      }
      len = strlen(fopt);
      strcat (my_argv, len > 1 ? "--" : "-");
      strcat (my_argv, fopt);
      if (len > 1 && ((farg && *farg) || equal))
        strcat (my_argv, "=");
      if (farg && *farg)
        strcat (my_argv, farg);
      ++(*my_argc);

      cmd_line_list_tmp = (struct line_list *) malloc (sizeof (struct line_list));
      cmd_line_list_tmp->next = cmd_line_list;
      cmd_line_list = cmd_line_list_tmp;
      cmd_line_list->string_arg = gengetopt_strdup(my_argv);
    } /* while */

  if (file)
    fclose(file);
  return result;
}

int
LaneDetectorParser_configfile (
  const char *filename,
                           struct LaneDetectorParserInfo *args_info,
                           int override, int initialize, int check_required)
{
  struct LaneDetectorParser_params params;

  params.override = override;
  params.initialize = initialize;
  params.check_required = check_required;
  params.check_ambiguity = 0;
  params.print_errors = 1;
  
  return LaneDetectorParser_config_file (filename, args_info, &params);
}

int
LaneDetectorParser_config_file (const char *filename,
                           struct LaneDetectorParserInfo *args_info,
                           struct LaneDetectorParser_params *params)
{
  int i, result;
  int my_argc = 1;
  char **my_argv_arg;
  char *additional_error;

  /* store the program name */
  cmd_line_list_tmp = (struct line_list *) malloc (sizeof (struct line_list));
  cmd_line_list_tmp->next = cmd_line_list;
  cmd_line_list = cmd_line_list_tmp;
  cmd_line_list->string_arg = gengetopt_strdup (LANEDETECTORPARSER_PACKAGE);

  result = _LaneDetectorParser_configfile(filename, &my_argc);

  if (result != EXIT_FAILURE) {
    my_argv_arg = (char **) malloc((my_argc+1) * sizeof(char *));
    cmd_line_list_tmp = cmd_line_list;

    for (i = my_argc - 1; i >= 0; --i) {
      my_argv_arg[i] = cmd_line_list_tmp->string_arg;
      cmd_line_list_tmp = cmd_line_list_tmp->next;
    }

    my_argv_arg[my_argc] = 0;

    additional_error = (char *)malloc(strlen(filename) + strlen(ADDITIONAL_ERROR) + 1);
    strcpy (additional_error, ADDITIONAL_ERROR);
    strcat (additional_error, filename);
    result =
      LaneDetectorParser_internal (my_argc, my_argv_arg, args_info,
                              params,
                              additional_error);

    free (additional_error);
    free (my_argv_arg);
  }

  free_cmd_list();
  if (result == EXIT_FAILURE)
    {
      LaneDetectorParser_free (args_info);
      exit (EXIT_FAILURE);
    }
  
  return result;
}
